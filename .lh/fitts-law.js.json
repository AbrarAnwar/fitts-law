{
    "sourceFile": "fitts-law.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 63,
            "patches": [
                {
                    "date": 1686102649326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1686103761104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1283 @@\n+\"use strict\";\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+const fs = require('fs').promises;\r\n+const path = require('path');\r\n+const process = require('process');\r\n+const {authenticate} = require('@google-cloud/local-auth');\r\n+const {google} = require('googleapis');\r\n+\r\n+const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+/**\r\n+ * Reads previously authorized credentials from the save file.\r\n+ *\r\n+ * @return {Promise<OAuth2Client|null>}\r\n+ */\r\n+async function loadSavedCredentialsIfExist() {\r\n+  try {\r\n+    const content = await fs.readFile(TOKEN_PATH);\r\n+    const credentials = JSON.parse(content);\r\n+    return google.auth.fromJSON(credentials);\r\n+  } catch (err) {\r\n+    return null;\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+ * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n+ *\r\n+ * @param {OAuth2Client} client\r\n+ * @return {Promise<void>}\r\n+ */\r\n+async function saveCredentials(client) {\r\n+  const content = await fs.readFile(CREDENTIALS_PATH);\r\n+  const keys = JSON.parse(content);\r\n+  const key = keys.installed || keys.web;\r\n+  const payload = JSON.stringify({\r\n+    type: 'authorized_user',\r\n+    client_id: key.client_id,\r\n+    client_secret: key.client_secret,\r\n+    refresh_token: client.credentials.refresh_token,\r\n+  });\r\n+  await fs.writeFile(TOKEN_PATH, payload);\r\n+}\r\n+\r\n+/**\r\n+ * Load or request or authorization to call APIs.\r\n+ *\r\n+ */\r\n+async function authorize() {\r\n+  let client = await loadSavedCredentialsIfExist();\r\n+  if (client) {\r\n+    return client;\r\n+  }\r\n+  client = await authenticate({\r\n+    scopes: SCOPES,\r\n+    keyfilePath: CREDENTIALS_PATH,\r\n+  });\r\n+  if (client.credentials) {\r\n+    await saveCredentials(client);\r\n+  }\r\n+  return client;\r\n+}\r\n+\r\n+\r\n+const {google} = require('googleapis');\r\n+const sheets = google.sheets('v4');\r\n+\r\n+async function primary(){\r\n+\tconst authClient = await authorize();\r\n+   \tconst request = {\r\n+\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+\trange: 'A1:AZ',  \r\n+\tvalueInputOption: 'RAW',  \r\n+\tinsertDataOption: 'OVERWRITE', \r\n+\tresource: {values: fittsTest.data},\r\n+\tauth: authClient,\r\n+\t};\r\n+\r\n+    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+    console.log(JSON.stringify(response, null, 2));\r\n+}\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tprimary();\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686103853374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1283 @@\n+\"use strict\";\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+const fs = require('fs').promises;\r\n+const path = require('path');\r\n+const process = require('process');\r\n+const {authenticate} = require('@google-cloud/local-auth');\r\n+const {google} = require('googleapis');\r\n+\r\n+const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+/**\r\n+ * Reads previously authorized credentials from the save file.\r\n+ *\r\n+ * @return {Promise<OAuth2Client|null>}\r\n+ */\r\n+async function loadSavedCredentialsIfExist() {\r\n+  try {\r\n+    const content = await fs.readFile(TOKEN_PATH);\r\n+    const credentials = JSON.parse(content);\r\n+    return google.auth.fromJSON(credentials);\r\n+  } catch (err) {\r\n+    return null;\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+ * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n+ *\r\n+ * @param {OAuth2Client} client\r\n+ * @return {Promise<void>}\r\n+ */\r\n+async function saveCredentials(client) {\r\n+  const content = await fs.readFile(CREDENTIALS_PATH);\r\n+  const keys = JSON.parse(content);\r\n+  const key = keys.installed || keys.web;\r\n+  const payload = JSON.stringify({\r\n+    type: 'authorized_user',\r\n+    client_id: key.client_id,\r\n+    client_secret: key.client_secret,\r\n+    refresh_token: client.credentials.refresh_token,\r\n+  });\r\n+  await fs.writeFile(TOKEN_PATH, payload);\r\n+}\r\n+\r\n+/**\r\n+ * Load or request or authorization to call APIs.\r\n+ *\r\n+ */\r\n+async function authorize() {\r\n+  let client = await loadSavedCredentialsIfExist();\r\n+  if (client) {\r\n+    return client;\r\n+  }\r\n+  client = await authenticate({\r\n+    scopes: SCOPES,\r\n+    keyfilePath: CREDENTIALS_PATH,\r\n+  });\r\n+  if (client.credentials) {\r\n+    await saveCredentials(client);\r\n+  }\r\n+  return client;\r\n+}\r\n+\r\n+\r\n+const {google} = require('googleapis');\r\n+const sheets = google.sheets('v4');\r\n+\r\n+async function primary(){\r\n+\tconst authClient = await authorize();\r\n+   \tconst request = {\r\n+\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+\trange: 'A1:AZ',  \r\n+\tvalueInputOption: 'RAW',  \r\n+\tinsertDataOption: 'OVERWRITE', \r\n+\tresource: {values: fittsTest.data},\r\n+\tauth: authClient,\r\n+\t};\r\n+\r\n+    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+    console.log(JSON.stringify(response, null, 2));\r\n+}\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tprimary();\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686104043456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1192,2670 +1192,92 @@\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n \r\n-const fs = require('fs').promises;\r\n-const path = require('path');\r\n-const process = require('process');\r\n-const {authenticate} = require('@google-cloud/local-auth');\r\n-const {google} = require('googleapis');\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n \r\n-const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n-/**\r\n- * Reads previously authorized credentials from the save file.\r\n- *\r\n- * @return {Promise<OAuth2Client|null>}\r\n- */\r\n-async function loadSavedCredentialsIfExist() {\r\n-  try {\r\n-    const content = await fs.readFile(TOKEN_PATH);\r\n-    const credentials = JSON.parse(content);\r\n-    return google.auth.fromJSON(credentials);\r\n-  } catch (err) {\r\n-    return null;\r\n-  }\r\n-}\r\n+// /**\r\n+//  * Reads previously authorized credentials from the save file.\r\n+//  *\r\n+//  * @return {Promise<OAuth2Client|null>}\r\n+//  */\r\n+// async function loadSavedCredentialsIfExist() {\r\n+//   try {\r\n+//     const content = await fs.readFile(TOKEN_PATH);\r\n+//     const credentials = JSON.parse(content);\r\n+//     return google.auth.fromJSON(credentials);\r\n+//   } catch (err) {\r\n+//     return null;\r\n+//   }\r\n+// }\r\n \r\n-/**\r\n- * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n- *\r\n- * @param {OAuth2Client} client\r\n- * @return {Promise<void>}\r\n- */\r\n-async function saveCredentials(client) {\r\n-  const content = await fs.readFile(CREDENTIALS_PATH);\r\n-  const keys = JSON.parse(content);\r\n-  const key = keys.installed || keys.web;\r\n-  const payload = JSON.stringify({\r\n-    type: 'authorized_user',\r\n-    client_id: key.client_id,\r\n-    client_secret: key.client_secret,\r\n-    refresh_token: client.credentials.refresh_token,\r\n-  });\r\n-  await fs.writeFile(TOKEN_PATH, payload);\r\n-}\r\n+// /**\r\n+//  * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n+//  *\r\n+//  * @param {OAuth2Client} client\r\n+//  * @return {Promise<void>}\r\n+//  */\r\n+// async function saveCredentials(client) {\r\n+//   const content = await fs.readFile(CREDENTIALS_PATH);\r\n+//   const keys = JSON.parse(content);\r\n+//   const key = keys.installed || keys.web;\r\n+//   const payload = JSON.stringify({\r\n+//     type: 'authorized_user',\r\n+//     client_id: key.client_id,\r\n+//     client_secret: key.client_secret,\r\n+//     refresh_token: client.credentials.refresh_token,\r\n+//   });\r\n+//   await fs.writeFile(TOKEN_PATH, payload);\r\n+// }\r\n \r\n-/**\r\n- * Load or request or authorization to call APIs.\r\n- *\r\n- */\r\n-async function authorize() {\r\n-  let client = await loadSavedCredentialsIfExist();\r\n-  if (client) {\r\n-    return client;\r\n-  }\r\n-  client = await authenticate({\r\n-    scopes: SCOPES,\r\n-    keyfilePath: CREDENTIALS_PATH,\r\n-  });\r\n-  if (client.credentials) {\r\n-    await saveCredentials(client);\r\n-  }\r\n-  return client;\r\n-}\r\n+// /**\r\n+//  * Load or request or authorization to call APIs.\r\n+//  *\r\n+//  */\r\n+// async function authorize() {\r\n+//   let client = await loadSavedCredentialsIfExist();\r\n+//   if (client) {\r\n+//     return client;\r\n+//   }\r\n+//   client = await authenticate({\r\n+//     scopes: SCOPES,\r\n+//     keyfilePath: CREDENTIALS_PATH,\r\n+//   });\r\n+//   if (client.credentials) {\r\n+//     await saveCredentials(client);\r\n+//   }\r\n+//   return client;\r\n+// }\r\n \r\n \r\n-const {google} = require('googleapis');\r\n-const sheets = google.sheets('v4');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4');\r\n \r\n-async function primary(){\r\n-\tconst authClient = await authorize();\r\n-   \tconst request = {\r\n-\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-\trange: 'A1:AZ',  \r\n-\tvalueInputOption: 'RAW',  \r\n-\tinsertDataOption: 'OVERWRITE', \r\n-\tresource: {values: fittsTest.data},\r\n-\tauth: authClient,\r\n-\t};\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1:AZ',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \tresource: {values: fittsTest.data},\r\n+// \tauth: authClient,\r\n+// \t};\r\n \r\n-    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-    console.log(JSON.stringify(response, null, 2));\r\n-}\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n \r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tprimary();\r\n+// $('#addDataSetButton').click(function() {\r\n+// \tfittsTest.addDataSet();\r\n+// \tfittsTest.active = false;\r\n+// \tprimary();\r\n \t\r\n-});\n-\"use strict\";\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-const fs = require('fs').promises;\r\n-const path = require('path');\r\n-const process = require('process');\r\n-const {authenticate} = require('@google-cloud/local-auth');\r\n-const {google} = require('googleapis');\r\n-\r\n-const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-/**\r\n- * Reads previously authorized credentials from the save file.\r\n- *\r\n- * @return {Promise<OAuth2Client|null>}\r\n- */\r\n-async function loadSavedCredentialsIfExist() {\r\n-  try {\r\n-    const content = await fs.readFile(TOKEN_PATH);\r\n-    const credentials = JSON.parse(content);\r\n-    return google.auth.fromJSON(credentials);\r\n-  } catch (err) {\r\n-    return null;\r\n-  }\r\n-}\r\n-\r\n-/**\r\n- * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n- *\r\n- * @param {OAuth2Client} client\r\n- * @return {Promise<void>}\r\n- */\r\n-async function saveCredentials(client) {\r\n-  const content = await fs.readFile(CREDENTIALS_PATH);\r\n-  const keys = JSON.parse(content);\r\n-  const key = keys.installed || keys.web;\r\n-  const payload = JSON.stringify({\r\n-    type: 'authorized_user',\r\n-    client_id: key.client_id,\r\n-    client_secret: key.client_secret,\r\n-    refresh_token: client.credentials.refresh_token,\r\n-  });\r\n-  await fs.writeFile(TOKEN_PATH, payload);\r\n-}\r\n-\r\n-/**\r\n- * Load or request or authorization to call APIs.\r\n- *\r\n- */\r\n-async function authorize() {\r\n-  let client = await loadSavedCredentialsIfExist();\r\n-  if (client) {\r\n-    return client;\r\n-  }\r\n-  client = await authenticate({\r\n-    scopes: SCOPES,\r\n-    keyfilePath: CREDENTIALS_PATH,\r\n-  });\r\n-  if (client.credentials) {\r\n-    await saveCredentials(client);\r\n-  }\r\n-  return client;\r\n-}\r\n-\r\n-\r\n-const {google} = require('googleapis');\r\n-const sheets = google.sheets('v4');\r\n-\r\n-async function primary(){\r\n-\tconst authClient = await authorize();\r\n-   \tconst request = {\r\n-\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-\trange: 'A1:AZ',  \r\n-\tvalueInputOption: 'RAW',  \r\n-\tinsertDataOption: 'OVERWRITE', \r\n-\tresource: {values: fittsTest.data},\r\n-\tauth: authClient,\r\n-\t};\r\n-\r\n-    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-    console.log(JSON.stringify(response, null, 2));\r\n-}\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tprimary();\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-const {google} = require('googleapis');\r\n-const sheets = google.sheets('v4');\r\n-\r\n-async function primary(){\r\n-\tconst authClient = await authorize();\r\n-   const request = {\r\n-  spreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-  range: 'A1:AZ',  \r\n-  valueInputOption: 'RAW',  \r\n-  insertDataOption: 'OVERWRITE', \r\n-  resource: {values: fittsTest.data},\r\n-  auth: authClient,\r\n-  };\r\n-}\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\t\r\n-\tprimary();\r\n-\r\n-\t\r\n-\t\r\n-});\r\n\\ No newline at end of file\n-\r\n-\r\n-\r\n-  \r\n-    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-    // TODO: Change code below to process the `response` object:\r\n-    console.log(JSON.stringify(response, null, 2));\r\n-\r\n-async function authorize() {\r\n-\t// TODO: Change placeholder below to generate authentication credentials. See\r\n-\t// https://developers.google.com/sheets/quickstart/nodejs#step_3_set_up_the_sample\r\n-\t//\r\n-\t// Authorize using one of the following scopes:\r\n-\t//   'https://www.googleapis.com/auth/drive'\r\n-\t//   'https://www.googleapis.com/auth/drive.file'\r\n-\t//   'https://www.googleapis.com/auth/spreadsheets'\r\n-\tlet authClient = null;\r\n-  \r\n-\tif (authClient == null) {\r\n-\t  throw Error('authentication failed');\r\n-\t}\r\n-  \r\n-\treturn authClient;\r\n-  }\r\n-\r\n-const fs = require('fs').promises;\r\n-const path = require('path');\r\n-const process = require('process');\r\n-const {authenticate} = require('@google-cloud/local-auth');\r\n-const {google} = require('googleapis');\r\n-\r\n-// If modifying these scopes, delete token.json.\r\n-const SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly'];\r\n-// The file token.json stores the user's access and refresh tokens, and is\r\n-// created automatically when the authorization flow completes for the first\r\n-// time.\r\n-const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-/**\r\n- * Reads previously authorized credentials from the save file.\r\n- *\r\n- * @return {Promise<OAuth2Client|null>}\r\n- */\r\n-async function loadSavedCredentialsIfExist() {\r\n-  try {\r\n-    const content = await fs.readFile(TOKEN_PATH);\r\n-    const credentials = JSON.parse(content);\r\n-    return google.auth.fromJSON(credentials);\r\n-  } catch (err) {\r\n-    return null;\r\n-  }\r\n-}\r\n-\r\n-/**\r\n- * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n- *\r\n- * @param {OAuth2Client} client\r\n- * @return {Promise<void>}\r\n- */\r\n-async function saveCredentials(client) {\r\n-  const content = await fs.readFile(CREDENTIALS_PATH);\r\n-  const keys = JSON.parse(content);\r\n-  const key = keys.installed || keys.web;\r\n-  const payload = JSON.stringify({\r\n-    type: 'authorized_user',\r\n-    client_id: key.client_id,\r\n-    client_secret: key.client_secret,\r\n-    refresh_token: client.credentials.refresh_token,\r\n-  });\r\n-  await fs.writeFile(TOKEN_PATH, payload);\r\n-}\r\n-\r\n-/**\r\n- * Load or request or authorization to call APIs.\r\n- *\r\n- */\n+// });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686104362307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1274,10 +1274,10 @@\n //     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n //     console.log(JSON.stringify(response, null, 2));\r\n // }\r\n \r\n-// $('#addDataSetButton').click(function() {\r\n-// \tfittsTest.addDataSet();\r\n-// \tfittsTest.active = false;\r\n-// \tprimary();\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n\\ No newline at end of file\n+\tfittsTest.active = false;\r\n+\tprimary();\r\n \t\r\n-// });\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686104547501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1192,92 +1192,62 @@\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n \r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n+const fs = require('fs').promises;\r\n+const path = require('path');\r\n+const process = require('process');\r\n+const {authenticate} = require('@google-cloud/local-auth');\r\n+const {google} = require('googleapis');\r\n \r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n-// /**\r\n-//  * Reads previously authorized credentials from the save file.\r\n-//  *\r\n-//  * @return {Promise<OAuth2Client|null>}\r\n-//  */\r\n-// async function loadSavedCredentialsIfExist() {\r\n-//   try {\r\n-//     const content = await fs.readFile(TOKEN_PATH);\r\n-//     const credentials = JSON.parse(content);\r\n-//     return google.auth.fromJSON(credentials);\r\n-//   } catch (err) {\r\n-//     return null;\r\n-//   }\r\n-// }\r\n \r\n-// /**\r\n-//  * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n-//  *\r\n-//  * @param {OAuth2Client} client\r\n-//  * @return {Promise<void>}\r\n-//  */\r\n-// async function saveCredentials(client) {\r\n-//   const content = await fs.readFile(CREDENTIALS_PATH);\r\n-//   const keys = JSON.parse(content);\r\n-//   const key = keys.installed || keys.web;\r\n-//   const payload = JSON.stringify({\r\n-//     type: 'authorized_user',\r\n-//     client_id: key.client_id,\r\n-//     client_secret: key.client_secret,\r\n-//     refresh_token: client.credentials.refresh_token,\r\n-//   });\r\n-//   await fs.writeFile(TOKEN_PATH, payload);\r\n-// }\r\n+async function loadSavedCredentialsIfExist() {\r\n+  try {\r\n+    const content = await fs.readFile(TOKEN_PATH);\r\n+    const credentials = JSON.parse(content);\r\n+    return google.auth.fromJSON(credentials);\r\n+  } catch (err) {\r\n+    return null;\r\n+  }\r\n+}\r\n \r\n-// /**\r\n-//  * Load or request or authorization to call APIs.\r\n-//  *\r\n-//  */\r\n-// async function authorize() {\r\n-//   let client = await loadSavedCredentialsIfExist();\r\n-//   if (client) {\r\n-//     return client;\r\n-//   }\r\n-//   client = await authenticate({\r\n-//     scopes: SCOPES,\r\n-//     keyfilePath: CREDENTIALS_PATH,\r\n-//   });\r\n-//   if (client.credentials) {\r\n-//     await saveCredentials(client);\r\n-//   }\r\n-//   return client;\r\n-// }\r\n \r\n+async function authorize() {\r\n+  let client = await loadSavedCredentialsIfExist();\r\n+  if (client) {\r\n+    return client;\r\n+  }\r\n+  client = await authenticate({\r\n+    scopes: SCOPES,\r\n+    keyfilePath: CREDENTIALS_PATH,\r\n+  });\r\n+  return client;\r\n+}\r\n \r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4');\r\n \r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1:AZ',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \tresource: {values: fittsTest.data},\r\n-// \tauth: authClient,\r\n-// \t};\r\n+const {google} = require('googleapis');\r\n+const sheets = google.sheets('v4');\r\n \r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n+async function primary(){\r\n+\tconst authClient = await authorize();\r\n+   \tconst request = {\r\n+\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+\trange: 'A1:AZ',  \r\n+\tvalueInputOption: 'RAW',  \r\n+\tinsertDataOption: 'OVERWRITE', \r\n+\tresource: {values: fittsTest.data},\r\n+\tauth: authClient,\r\n+\t};\r\n \r\n+    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+    console.log(JSON.stringify(response, null, 2));\r\n+}\r\n+\r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n \tprimary();\r\n-\t\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686104577061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1192,14 +1192,8 @@\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n \r\n-const fs = require('fs').promises;\r\n-const path = require('path');\r\n-const process = require('process');\r\n-const {authenticate} = require('@google-cloud/local-auth');\r\n-const {google} = require('googleapis');\r\n-\r\n const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n"
                },
                {
                    "date": 1686104634125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1192,21 +1192,20 @@\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n \r\n+const {google} = require('googleapis');\r\n+const sheets = google.sheets('v4'); \r\n+\r\n const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n \r\n async function loadSavedCredentialsIfExist() {\r\n-  try {\r\n     const content = await fs.readFile(TOKEN_PATH);\r\n     const credentials = JSON.parse(content);\r\n     return google.auth.fromJSON(credentials);\r\n-  } catch (err) {\r\n-    return null;\r\n-  }\r\n }\r\n \r\n \r\n async function authorize() {\r\n@@ -1221,10 +1220,8 @@\n   return client;\r\n }\r\n \r\n \r\n-const {google} = require('googleapis');\r\n-const sheets = google.sheets('v4');\r\n \r\n async function primary(){\r\n \tconst authClient = await authorize();\r\n    \tconst request = {\r\n"
                },
                {
                    "date": 1686104641470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1209,11 +1209,8 @@\n \r\n \r\n async function authorize() {\r\n   let client = await loadSavedCredentialsIfExist();\r\n-  if (client) {\r\n-    return client;\r\n-  }\r\n   client = await authenticate({\r\n     scopes: SCOPES,\r\n     keyfilePath: CREDENTIALS_PATH,\r\n   });\r\n"
                },
                {
                    "date": 1686105073658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1200,22 +1200,19 @@\n const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n \r\n-async function loadSavedCredentialsIfExist() {\r\n-    const content = await fs.readFile(TOKEN_PATH);\r\n-    const credentials = JSON.parse(content);\r\n-    return google.auth.fromJSON(credentials);\r\n-}\r\n \r\n \r\n async function authorize() {\r\n-  let client = await loadSavedCredentialsIfExist();\r\n-  client = await authenticate({\r\n-    scopes: SCOPES,\r\n-    keyfilePath: CREDENTIALS_PATH,\r\n-  });\r\n-  return client;\r\n+\tconst content = await fs.readFile(TOKEN_PATH);\r\n+\tconst credentials = JSON.parse(content);\r\n+\tlet client = google.auth.fromJSON(credentials);\r\n+\tclient = await authenticate({\r\n+\t\tscopes: SCOPES,\r\n+\t\tkeyfilePath: CREDENTIALS_PATH,\r\n+\t});\r\n+\treturn client;\r\n }\r\n \r\n \r\n \r\n@@ -1225,9 +1222,9 @@\n \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n \trange: 'A1:AZ',  \r\n \tvalueInputOption: 'RAW',  \r\n \tinsertDataOption: 'OVERWRITE', \r\n-\tresource: {values: fittsTest.data},\r\n+\tresource: fittsTest.data,\r\n \tauth: authClient,\r\n \t};\r\n \r\n     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n"
                },
                {
                    "date": 1686105223057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1219,9 +1219,9 @@\n async function primary(){\r\n \tconst authClient = await authorize();\r\n    \tconst request = {\r\n \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-\trange: 'A1:AZ',  \r\n+\trange: 'A1:H25',  \r\n \tvalueInputOption: 'RAW',  \r\n \tinsertDataOption: 'OVERWRITE', \r\n \tresource: fittsTest.data,\r\n \tauth: authClient,\r\n"
                },
                {
                    "date": 1686105322211,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,9 +1191,12 @@\n $('#randomizeCheckbox').change(function(event) {\r\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n-\r\n+const fs = require('fs').promises;\r\n+const path = require('path');\r\n+const process = require('process');\r\n+const {authenticate} = require('@google-cloud/local-auth');\r\n const {google} = require('googleapis');\r\n const sheets = google.sheets('v4'); \r\n \r\n const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n"
                },
                {
                    "date": 1686105383833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,49 +1191,49 @@\n $('#randomizeCheckbox').change(function(event) {\r\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n-const fs = require('fs').promises;\r\n-const path = require('path');\r\n-const process = require('process');\r\n-const {authenticate} = require('@google-cloud/local-auth');\r\n-const {google} = require('googleapis');\r\n-const sheets = google.sheets('v4'); \r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n \r\n-const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n \r\n \r\n \r\n-async function authorize() {\r\n-\tconst content = await fs.readFile(TOKEN_PATH);\r\n-\tconst credentials = JSON.parse(content);\r\n-\tlet client = google.auth.fromJSON(credentials);\r\n-\tclient = await authenticate({\r\n-\t\tscopes: SCOPES,\r\n-\t\tkeyfilePath: CREDENTIALS_PATH,\r\n-\t});\r\n-\treturn client;\r\n-}\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n \r\n \r\n \r\n-async function primary(){\r\n-\tconst authClient = await authorize();\r\n-   \tconst request = {\r\n-\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-\trange: 'A1:H25',  \r\n-\tvalueInputOption: 'RAW',  \r\n-\tinsertDataOption: 'OVERWRITE', \r\n-\tresource: fittsTest.data,\r\n-\tauth: authClient,\r\n-\t};\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1:H25',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \tresource: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n \r\n-    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-    console.log(JSON.stringify(response, null, 2));\r\n-}\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n"
                },
                {
                    "date": 1686105459751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1222,9 +1222,9 @@\n // async function primary(){\r\n // \tconst authClient = await authorize();\r\n //    \tconst request = {\r\n // \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1:H25',  \r\n+// \trange: 'A1',  \r\n // \tvalueInputOption: 'RAW',  \r\n // \tinsertDataOption: 'OVERWRITE', \r\n // \tresource: fittsTest.data,\r\n // \tauth: authClient,\r\n"
                },
                {
                    "date": 1686105468488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,49 +1191,49 @@\n $('#randomizeCheckbox').change(function(event) {\r\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n+const fs = require('fs').promises;\r\n+const path = require('path');\r\n+const process = require('process');\r\n+const {authenticate} = require('@google-cloud/local-auth');\r\n+const {google} = require('googleapis');\r\n+const sheets = google.sheets('v4'); \r\n \r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n \r\n \r\n \r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n+async function authorize() {\r\n+\tconst content = await fs.readFile(TOKEN_PATH);\r\n+\tconst credentials = JSON.parse(content);\r\n+\tlet client = google.auth.fromJSON(credentials);\r\n+\tclient = await authenticate({\r\n+\t\tscopes: SCOPES,\r\n+\t\tkeyfilePath: CREDENTIALS_PATH,\r\n+\t});\r\n+\treturn client;\r\n+}\r\n \r\n \r\n \r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \tresource: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n+async function primary(){\r\n+\tconst authClient = await authorize();\r\n+   \tconst request = {\r\n+\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+\trange: 'A1',  \r\n+\tvalueInputOption: 'RAW',  \r\n+\tinsertDataOption: 'OVERWRITE', \r\n+\tresource: fittsTest.data,\r\n+\tauth: authClient,\r\n+\t};\r\n \r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n+    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+    console.log(JSON.stringify(response, null, 2));\r\n+}\r\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n"
                },
                {
                    "date": 1686105886701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1225,9 +1225,9 @@\n \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n \trange: 'A1',  \r\n \tvalueInputOption: 'RAW',  \r\n \tinsertDataOption: 'OVERWRITE', \r\n-\tresource: fittsTest.data,\r\n+\trequestBody: fittsTest.data,\r\n \tauth: authClient,\r\n \t};\r\n \r\n     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n"
                },
                {
                    "date": 1686106515867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,8 +1191,10 @@\n $('#randomizeCheckbox').change(function(event) {\r\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n+\r\n+\r\n const fs = require('fs').promises;\r\n const path = require('path');\r\n const process = require('process');\r\n const {authenticate} = require('@google-cloud/local-auth');\r\n"
                },
                {
                    "date": 1686106778922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1193,51 +1193,51 @@\n })\r\n \r\n \r\n \r\n-const fs = require('fs').promises;\r\n-const path = require('path');\r\n-const process = require('process');\r\n-const {authenticate} = require('@google-cloud/local-auth');\r\n-const {google} = require('googleapis');\r\n-const sheets = google.sheets('v4'); \r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n \r\n-const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n \r\n \r\n \r\n \r\n-async function authorize() {\r\n-\tconst content = await fs.readFile(TOKEN_PATH);\r\n-\tconst credentials = JSON.parse(content);\r\n-\tlet client = google.auth.fromJSON(credentials);\r\n-\tclient = await authenticate({\r\n-\t\tscopes: SCOPES,\r\n-\t\tkeyfilePath: CREDENTIALS_PATH,\r\n-\t});\r\n-\treturn client;\r\n-}\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n \r\n \r\n \r\n-async function primary(){\r\n-\tconst authClient = await authorize();\r\n-   \tconst request = {\r\n-\tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-\trange: 'A1',  \r\n-\tvalueInputOption: 'RAW',  \r\n-\tinsertDataOption: 'OVERWRITE', \r\n-\trequestBody: fittsTest.data,\r\n-\tauth: authClient,\r\n-\t};\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n \r\n-    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-    console.log(JSON.stringify(response, null, 2));\r\n-}\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tprimary();\r\n+\t// primary();\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686107080896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,10 +1191,10 @@\n $('#randomizeCheckbox').change(function(event) {\r\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n+import { JsonArray, download } from 'json-to-csv-in-browser'\r\n \r\n-\r\n // const fs = require('fs').promises;\r\n // const path = require('path');\r\n // const process = require('process');\r\n // const {authenticate} = require('@google-cloud/local-auth');\r\n@@ -1239,5 +1239,8 @@\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n \t// primary();\r\n+\tconst jsonArray = new JsonArray(fittsTest.data);\r\n+\tconst str = jsonArray.convertToCSVstring();\r\n+\tdownload(\"my.csv\", str);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686107122033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,8 @@\n \"use strict\";\r\n \r\n+import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n /**\r\n  * Create dimensions from the given values and store them for later use.\r\n  * All values should be positive and make sense.\r\n  * @param {number} width The outer width of the area.\r\n@@ -1191,9 +1193,8 @@\n $('#randomizeCheckbox').change(function(event) {\r\n \tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n })\r\n \r\n-import { JsonArray, download } from 'json-to-csv-in-browser'\r\n \r\n // const fs = require('fs').promises;\r\n // const path = require('path');\r\n // const process = require('process');\r\n"
                },
                {
                    "date": 1686107151589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\t// primary();\r\n-\tconst jsonArray = new JsonArray(fittsTest.data);\r\n-\tconst str = jsonArray.convertToCSVstring();\r\n-\tdownload(\"my.csv\", str);\r\n+\t// // primary();\r\n+\t// const jsonArray = new JsonArray(fittsTest.data);\r\n+\t// const str = jsonArray.convertToCSVstring();\r\n+\t// download(\"my.csv\", str);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686107163617,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n \"use strict\";\r\n \r\n-import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n \r\n /**\r\n  * Create dimensions from the given values and store them for later use.\r\n  * All values should be positive and make sense.\r\n"
                },
                {
                    "date": 1686107449192,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,8 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data)\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686107783544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data)\r\n+\tconsole.log(fittsTest.data[currentDataSet])\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686107843766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[currentDataSet])\r\n+\tconsole.log(fittsTest.data[fittsTest.currentDataSet])\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686107878891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.currentDataSet])\r\n+\tconsole.log(fittsTest.data[fittsTest.currentDataSet].data)\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686107908405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.currentDataSet].data)\r\n+\tconsole.log(fittsTest.data[fittsTest.currentDataSet])\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686108000644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.currentDataSet])\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt])\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686108074144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt])\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt -1])\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686108107923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1239,9 +1239,9 @@\n \r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt -1])\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n"
                },
                {
                    "date": 1686108247890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1244,5 +1244,10 @@\n \t// // primary();\r\n \t// const jsonArray = new JsonArray(fittsTest.data);\r\n \t// const str = jsonArray.convertToCSVstring();\r\n \t// download(\"my.csv\", str);\r\n+\r\n+\tlet csvContent = \"data:text/csv;charset=utf-8,\" \r\n+    + fittsTest.data[fittsTest.dataCnt - 1].data.map(e => e.join(\",\")).join(\"\\n\");\r\n+\tvar encodedUri = encodeURI(csvContent);\r\n+\twindow.open(encodedUri);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686108743817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1236,18 +1236,39 @@\n //     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n //     console.log(JSON.stringify(response, null, 2));\r\n // }\r\n \r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n \tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-\t// // primary();\r\n-\t// const jsonArray = new JsonArray(fittsTest.data);\r\n-\t// const str = jsonArray.convertToCSVstring();\r\n-\t// download(\"my.csv\", str);\r\n+});\r\n \r\n-\tlet csvContent = \"data:text/csv;charset=utf-8,\" \r\n-    + fittsTest.data[fittsTest.dataCnt - 1].data.map(e => e.join(\",\")).join(\"\\n\");\r\n-\tvar encodedUri = encodeURI(csvContent);\r\n-\twindow.open(encodedUri);\r\n+$('#downloadDataButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+\r\n+\t\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686108751439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1236,30 +1236,8 @@\n //     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n //     console.log(JSON.stringify(response, null, 2));\r\n // }\r\n \r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n $('#addDataSetButton').click(function() {\r\n \tfittsTest.addDataSet();\r\n \tfittsTest.active = false;\r\n \tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n"
                },
                {
                    "date": 1686109046490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1281 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tnewData.push(fittsTest.data[i].data)\r\n+    \ti++;\r\n+\t}\r\n+\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109168101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1283 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tnewData.push(fittsTest.data[i].data)\r\n+    \ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109312904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1283 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tnewData.push(fittsTest.data[i])\r\n+    \ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109344303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1283 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tnewData.push(fittsTest.data[i])\r\n+    \ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109683621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1285 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= lengthfittsTest.data[i].data.length) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109717132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1285 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109756989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length) {\r\n+\t\t\tconsole.log([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109766092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length) {\r\n+\t\t\tconsole.log([i, fittsTest.data[i].data[j]]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109862648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109919646,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686109938692,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110086091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110130702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110203301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1287 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t\ti++\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110209222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1288 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\tj++\r\n+\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t}\r\n+\t\ti++\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110215470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1288 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++\r\n+\t\t}\r\n+\t\ti++\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110223063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1288 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 0;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110231015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1288 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 1;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110286071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1288 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\t// console.log(newData);\r\n+\r\n+\t// let csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110313233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1287 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110595711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1317 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\tvar processRow = function (row) {\r\n+        var finalVal = '';\r\n+        for (var j = 0; j < row.length; j++) {\r\n+            var innerValue = row[j] === null ? '' : row[j].toString();\r\n+            if (row[j] instanceof Date) {\r\n+                innerValue = row[j].toLocaleString();\r\n+            };\r\n+            var result = innerValue.replace(/\"/g, '\"\"');\r\n+            if (result.search(/(\"|,|\\n)/g) >= 0)\r\n+                result = '\"' + result + '\"';\r\n+            if (j > 0)\r\n+                finalVal += ',';\r\n+            finalVal += result;\r\n+        }\r\n+        return finalVal + '\\n';\r\n+    };\r\n+\r\n+    var csvFile = '';\r\n+    for (var i = 0; i < rows.length; i++) {\r\n+        csvFile += processRow(rows[i]);\r\n+    }\r\n+\r\n+    var blob = new Blob([csvFile], { type: 'text/csv;charset=utf-8;' });\r\n+    if (navigator.msSaveBlob) { // IE 10+\r\n+        navigator.msSaveBlob(blob, filename);\r\n+    } else {\r\n+        var link = document.createElement(\"a\");\r\n+        if (link.download !== undefined) { // feature detection\r\n+            // Browsers that support HTML5 download attribute\r\n+            var url = URL.createObjectURL(blob);\r\n+            link.setAttribute(\"href\", url);\r\n+            link.setAttribute(\"download\", filename);\r\n+            link.style.visibility = 'hidden';\r\n+            document.body.appendChild(link);\r\n+            link.click();\r\n+            document.body.removeChild(link);\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+// function downloadBlob(content, filename, contentType) {\r\n+// \t// Create a blob\r\n+// \tvar blob = new Blob([content], { type: contentType });\r\n+// \tvar url = URL.createObjectURL(blob);\r\n+  \r\n+// \t// Create a link to download it\r\n+// \tvar pom = document.createElement('a');\r\n+// \tpom.href = url;\r\n+// \tpom.setAttribute('download', filename);\r\n+// \tpom.click();\r\n+// }\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tcsv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110632615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1317 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(filename, rows) {\r\n+\tvar processRow = function (row) {\r\n+        var finalVal = '';\r\n+        for (var j = 0; j < row.length; j++) {\r\n+            var innerValue = row[j] === null ? '' : row[j].toString();\r\n+            if (row[j] instanceof Date) {\r\n+                innerValue = row[j].toLocaleString();\r\n+            };\r\n+            var result = innerValue.replace(/\"/g, '\"\"');\r\n+            if (result.search(/(\"|,|\\n)/g) >= 0)\r\n+                result = '\"' + result + '\"';\r\n+            if (j > 0)\r\n+                finalVal += ',';\r\n+            finalVal += result;\r\n+        }\r\n+        return finalVal + '\\n';\r\n+    };\r\n+\r\n+    var csvFile = '';\r\n+    for (var i = 0; i < rows.length; i++) {\r\n+        csvFile += processRow(rows[i]);\r\n+    }\r\n+\r\n+    var blob = new Blob([csvFile], { type: 'text/csv;charset=utf-8;' });\r\n+    if (navigator.msSaveBlob) { // IE 10+\r\n+        navigator.msSaveBlob(blob, filename);\r\n+    } else {\r\n+        var link = document.createElement(\"a\");\r\n+        if (link.download !== undefined) { // feature detection\r\n+            // Browsers that support HTML5 download attribute\r\n+            var url = URL.createObjectURL(blob);\r\n+            link.setAttribute(\"href\", url);\r\n+            link.setAttribute(\"download\", filename);\r\n+            link.style.visibility = 'hidden';\r\n+            document.body.appendChild(link);\r\n+            link.click();\r\n+            document.body.removeChild(link);\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+// function downloadBlob(content, filename, contentType) {\r\n+// \t// Create a blob\r\n+// \tvar blob = new Blob([content], { type: contentType });\r\n+// \tvar url = URL.createObjectURL(blob);\r\n+  \r\n+// \t// Create a link to download it\r\n+// \tvar pom = document.createElement('a');\r\n+// \tpom.href = url;\r\n+// \tpom.setAttribute('download', filename);\r\n+// \tpom.click();\r\n+// }\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110833139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1317 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(filename, rows) {\r\n+\tvar processRow = function (row) {\r\n+        var finalVal = '';\r\n+        for (var j = 0; j < row.length; j++) {\r\n+            var innerValue = row[j] === null ? '' : row[j].toString();\r\n+            if (row[j] instanceof Date) {\r\n+                innerValue = row[j].toLocaleString();\r\n+            };\r\n+            var result = innerValue.replace(/\"/g, '\"\"');\r\n+            if (result.search(/(\"|,|\\n)/g) >= 0)\r\n+                result = '\"' + result + '\"';\r\n+            if (j > 0)\r\n+                finalVal += ',';\r\n+            finalVal += result;\r\n+        }\r\n+        return finalVal + '\\n';\r\n+    };\r\n+\r\n+    var csvFile = '';\r\n+    for (var i = 1; i < rows.length; i++) {\r\n+        csvFile += processRow(rows[i]);\r\n+    }\r\n+\r\n+    var blob = new Blob([csvFile], { type: 'text/csv;charset=utf-8;' });\r\n+    if (navigator.msSaveBlob) { // IE 10+\r\n+        navigator.msSaveBlob(blob, filename);\r\n+    } else {\r\n+        var link = document.createElement(\"a\");\r\n+        if (link.download !== undefined) { // feature detection\r\n+            // Browsers that support HTML5 download attribute\r\n+            var url = URL.createObjectURL(blob);\r\n+            link.setAttribute(\"href\", url);\r\n+            link.setAttribute(\"download\", filename);\r\n+            link.style.visibility = 'hidden';\r\n+            document.body.appendChild(link);\r\n+            link.click();\r\n+            document.body.removeChild(link);\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+// function downloadBlob(content, filename, contentType) {\r\n+// \t// Create a blob\r\n+// \tvar blob = new Blob([content], { type: contentType });\r\n+// \tvar url = URL.createObjectURL(blob);\r\n+  \r\n+// \t// Create a link to download it\r\n+// \tvar pom = document.createElement('a');\r\n+// \tpom.href = url;\r\n+// \tpom.setAttribute('download', filename);\r\n+// \tpom.click();\r\n+// }\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = arrayToCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686110969963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1286 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function arrayToCsv(data){\r\n+\treturn data.map(row =>\r\n+\t  row\r\n+\t  .map(String)  // convert every value to String\r\n+\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+\t  .map(v => `\"${v}\"`)  // quote it\r\n+\t  .join(',')  // comma-separated\r\n+\t).join('\\r\\n');  // rows starting on new lines\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = arrayToCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686111566592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1312 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+function pivot(arr) {\r\n+    var mp = new Map();\r\n+    \r\n+    function setValue(a, path, val) {\r\n+        if (Object(val) !== val) { // primitive value\r\n+            var pathStr = path.join('.');\r\n+            var i = (mp.has(pathStr) ? mp : mp.set(pathStr, mp.size)).get(pathStr);\r\n+            a[i] = val;\r\n+        } else {\r\n+            for (var key in val) {\r\n+                setValue(a, key == '0' ? path : path.concat(key), val[key]);\r\n+            }\r\n+        }\r\n+        return a;\r\n+    }\r\n+    \r\n+    var result = arr.map( obj => setValue([], [], obj) );\r\n+    return [[...mp.keys()], ...result];\r\n+}\r\n+\r\n+function toCsv(arr) {\r\n+    return arr.map( row => \r\n+        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n+    ).join('\\n');\r\n+}\r\n+\r\n+// function arrayToCsv(data){\r\n+// \treturn data.map(row =>\r\n+// \t  row\r\n+// \t  .map(String)  // convert every value to String\r\n+// \t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+// \t  .map(v => `\"${v}\"`)  // quote it\r\n+// \t  .join(',')  // comma-separated\r\n+// \t).join('\\r\\n');  // rows starting on new lines\r\n+// }\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = toCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686112154986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1312 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+\r\n+// const fs = require('fs').promises;\r\n+// const path = require('path');\r\n+// const process = require('process');\r\n+// const {authenticate} = require('@google-cloud/local-auth');\r\n+// const {google} = require('googleapis');\r\n+// const sheets = google.sheets('v4'); \r\n+\r\n+// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n+// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n+// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n+\r\n+\r\n+\r\n+\r\n+// async function authorize() {\r\n+// \tconst content = await fs.readFile(TOKEN_PATH);\r\n+// \tconst credentials = JSON.parse(content);\r\n+// \tlet client = google.auth.fromJSON(credentials);\r\n+// \tclient = await authenticate({\r\n+// \t\tscopes: SCOPES,\r\n+// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n+// \t});\r\n+// \treturn client;\r\n+// }\r\n+\r\n+\r\n+\r\n+// async function primary(){\r\n+// \tconst authClient = await authorize();\r\n+//    \tconst request = {\r\n+// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n+// \trange: 'A1',  \r\n+// \tvalueInputOption: 'RAW',  \r\n+// \tinsertDataOption: 'OVERWRITE', \r\n+// \trequestBody: fittsTest.data,\r\n+// \tauth: authClient,\r\n+// \t};\r\n+\r\n+//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n+//     console.log(JSON.stringify(response, null, 2));\r\n+// }\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n+});\r\n+\r\n+// function pivot(arr) {\r\n+//     var mp = new Map();\r\n+    \r\n+//     function setValue(a, path, val) {\r\n+//         if (Object(val) !== val) { // primitive value\r\n+//             var pathStr = path.join('.');\r\n+//             var i = (mp.has(pathStr) ? mp : mp.set(pathStr, mp.size)).get(pathStr);\r\n+//             a[i] = val;\r\n+//         } else {\r\n+//             for (var key in val) {\r\n+//                 setValue(a, key == '0' ? path : path.concat(key), val[key]);\r\n+//             }\r\n+//         }\r\n+//         return a;\r\n+//     }\r\n+    \r\n+//     var result = arr.map( obj => setValue([], [], obj) );\r\n+//     return [[...mp.keys()], ...result];\r\n+// }\r\n+\r\n+function toCsv(arr) {\r\n+    return arr.map( row => \r\n+        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n+    ).join('\\n');\r\n+}\r\n+\r\n+// function arrayToCsv(data){\r\n+// \treturn data.map(row =>\r\n+// \t  row\r\n+// \t  .map(String)  // convert every value to String\r\n+// \t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n+// \t  .map(v => `\"${v}\"`)  // quote it\r\n+// \t  .join(',')  // comma-separated\r\n+// \t).join('\\r\\n');  // rows starting on new lines\r\n+// }\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = toCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686112431316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1240 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n+});\r\n+\r\n+\r\n+function toCsv(arr) {\r\n+    return arr.map( row => \r\n+        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n+    ).join('\\n');\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\tlet newData = []\r\n+\r\n+\twhile (i <= fittsTest.dataCnt - 1) {\r\n+    \tlet j = 0;\r\n+\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n+\t\t\tj++;\r\n+\t\t}\r\n+\t\ti++;\r\n+\t}\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = toCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686112794147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1240 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n+});\r\n+\r\n+\r\n+function toCsv(arr) {\r\n+    return arr.map( row => \r\n+        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n+    ).join('\\n');\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\t// let newData = []\r\n+\r\n+\t// while (i <= fittsTest.dataCnt - 1) {\r\n+    // \tlet j = 0;\r\n+\t// \twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t// \t\tnewData.push({i : fittsTest.data[i].data[j]});\r\n+\t// \t\tj++;\r\n+\t// \t}\r\n+\t// \ti++;\r\n+\t// }\r\n+\r\n+\tconsole.log(newData);\r\n+\tlet csv = toCsv(newData);\r\n+\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\t\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686112908872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1241 @@\n+\"use strict\";\r\n+\r\n+// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n+\r\n+/**\r\n+ * Create dimensions from the given values and store them for later use.\r\n+ * All values should be positive and make sense.\r\n+ * @param {number} width The outer width of the area.\r\n+ * @param {number} height The outer height of the area.\r\n+ * @param {number} top Margin form the top edge.\r\n+ * @param {number} right Margin form the right edge.\r\n+ * @param {number} bottom Margin form the bottom edge.\r\n+ * @param {number} left Margin form the left edge.\r\n+ */\r\n+function makeDimension(width, height, top, right, bottom, left) {\r\n+\treturn {width: width,\r\n+\t\theight: height,\r\n+\t\tinnerWidth: width - (left + right),\r\n+\t\tinnerHeight: height - (top + bottom),\r\n+\t\ttop: top,\r\n+\t\tright: right,\r\n+\t\tbottom: bottom,\r\n+\t\tleft: left,\r\n+\t\tcx: (width - (left + right)) / 2 + left,\r\n+\t\tcy: (height - (top + bottom)) / 2 + top};\r\n+}\r\n+\r\n+// set up dimensions for the plotting.\r\n+var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n+var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n+var plotVelocitiesDimension = plotPositionDimension;\r\n+var plotHitsDimension = plotPositionDimension;\r\n+var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n+var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n+var speedEffectiveDimension = positionEffectiveDimension;\r\n+var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n+\r\n+var LIVE_STAY = 1000;\r\n+var MAX_TIME = 2000;\r\n+var UPDATE_DELAY = MAX_TIME;\r\n+var MAX_SPEED = 6; // pixel/ms\r\n+\r\n+function rHit(r, rTarget) {\r\n+\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n+};\r\n+\r\n+\r\n+\r\n+function v(v) {\r\n+\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n+\treturn colour;\r\n+};\r\n+\r\n+var scatterX = d3.scale.linear()\r\n+\t.domain([0.5, 5.5])\r\n+\t.range([0, plotScatterDimension.innerWidth]);\r\n+\r\n+var scatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, plotScatterDimension.innerHeight]);\r\n+\r\n+var scaleT = d3.scale.linear()\r\n+\t.domain([0, 1000])\r\n+\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n+\r\n+var scaleV = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n+\r\n+var scaleX = d3.scale.linear()\r\n+\t.domain([-20, 300])\r\n+\t.range([0, plotPositionDimension.innerWidth]);\r\n+\r\n+var scaleY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([plotPositionDimension.innerHeight, 0]);\r\n+\r\n+var effScatterX = d3.scale.linear()\r\n+\t.domain([0.5, 6.5])\r\n+\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n+\r\n+var effScatterY = d3.scale.linear()\r\n+\t.domain([MAX_TIME, 0])\r\n+\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n+\r\n+var effPositionX = d3.scale.linear()\r\n+\t.domain([-60, 400])\r\n+\t.range([0, positionEffectiveDimension.innerWidth]);\r\n+\r\n+var effPositionY = d3.scale.linear()\r\n+\t.domain([-50, 50])\r\n+\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n+\t\r\n+var effSpeedX = d3.scale.linear()\r\n+\t.domain([0, MAX_TIME])\r\n+\t.range([0, speedEffectiveDimension.innerWidth])\r\n+\r\n+var effSpeedY = d3.scale.linear()\r\n+\t.domain([0, MAX_SPEED])\r\n+\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n+\r\n+\r\n+\r\n+var fittsTest = {\r\n+\ttarget: {x: 0, y: 0, r: 10},\r\n+\tstart: {x: 0, y: 0, t: 0},\r\n+\tlast: {},\r\n+\r\n+\tisoPositions: [],\r\n+\tcurrentPosition: 0,\r\n+\tcurrentCount: 0,\r\n+\tmiss: 0,\r\n+\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n+\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n+\t\r\n+\tcurrentPath: [],\r\n+\tactive: false,\r\n+\t\r\n+\tdata: [],\r\n+\tcurrentDataSet: 0,\r\n+\tdataCnt: 0,\r\n+\t\r\n+\tcolour: d3.scale.category10(),\r\n+\t\r\n+\tsumID: 0,\r\n+\tsumTime: 0,\r\n+\t\r\n+\tupdateTimeoutHandle: undefined,\r\n+\t\r\n+\tgenerateTarget: function() {\r\n+\t\tthis.target = this.isoPositions[this.currentPosition];\r\n+\t\tthis.target.distance = this.isoParams.distance;\r\n+\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n+\t\t\r\n+\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\ttarget.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('id', 'target')\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\ttarget.transition()\r\n+\t\t\t\t.call(insert);\r\n+\r\n+\t\t\r\n+\t\tthis.active = true;\r\n+\t},\r\n+\t\r\n+\tupdateISOCircles: function() {\r\n+\t\tthis.currentCount = 0;\r\n+\t\t\r\n+\t\tthis.generateISOPositions(this.isoParams.num,\r\n+\t\t\tthis.isoParams.distance,\r\n+\t\t\tthis.isoParams.width);\r\n+\r\n+\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n+\t\t\r\n+\t\tvar insert = function(d) {\r\n+\t\t\td.attr('cx', function(d) { return d.x; })\r\n+\t\t\t.attr('cy', function(d) { return d.y; })\r\n+\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n+\t\t}\r\n+\r\n+\t\tcircles.enter()\r\n+\t\t\t.append('circle')\r\n+\t\t\t\t.attr('class', 'iso')\r\n+\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\t\t\t\t\r\n+\t\tcircles.transition()\r\n+\t\t\t.call(insert);\r\n+\t\t\r\n+\t\tcircles.exit()\r\n+\t\t\t.transition()\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.currentPosition = 0;\r\n+\t\tthis.generateTarget();\r\n+\t\tthis.active = false;\r\n+},\r\n+\t\r\n+\tgenerateISOPositions: function(num, d, w) {\r\n+\t\t\r\n+\t\t// remove all data from live view\r\n+\t\tplotHitsGroup.selectAll('circle.hit')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t.attr('r', 2)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\r\n+\t\tplotPositionGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\r\n+\t\tplotVelocitiesGroup.selectAll('line.live')\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t.remove();\r\n+\t\t\r\n+\t\t\r\n+\t\tthis.isoPositions = [];\r\n+\t\t\r\n+\t\tfor (var i = 0; i < num; i++) {\r\n+\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n+\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n+\t\t\t\tw: w};\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tremoveTarget: function() {\r\n+\t\ttestAreaSVG.selectAll('#target').data([])\r\n+\t\t\t.exit()\r\n+\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\tthis.active = false;\r\n+\t\tthis.currentPath = [];\r\n+\t},\r\n+\t\r\n+\tmouseClicked: function(x, y) {\r\n+\t\t\r\n+\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n+\t\t\tthis.addDataPoint({start: this.start,\r\n+\t\t\t\t\t\t\t   target: this.target,\r\n+\t\t\t\t\t\t\t   path: this.currentPath,\r\n+\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n+\t\t\tthis.removeTarget();\r\n+\r\n+\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n+\t\t\t\tthis.randomizeParams();\r\n+\t\t\t\tthis.currentCount = 0;\r\n+\t\t\t\tthis.currentPosition = 0;\r\n+\t\t\t\tthis.miss = 0;\r\n+\t\t\t\tthis.updateISOCircles;\r\n+\t\t\t\tthis.generateTarget();\r\n+\t\t\t\tthis.active = false;\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tthis.currentCount++;\r\n+\t\t\t\tthis.generateTarget();\t\t\t\r\n+\t\t\t}\r\n+\r\n+\t\t\t\r\n+\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n+\t\t\tthis.start = this.last;\r\n+\t\t\tthis.currentPath.push(this.last);\r\n+\t\t}\r\n+\t\telse {\r\n+\t\t\tthis.miss++;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\tmouseMoved: function(x, y) {\r\n+\t\tif (this.active) {\r\n+\t\t\t// skip if the mouse did actually not move\r\n+\t\t\t// that should practically never happen...\r\n+\t\t\tif (x == this.last.x && y == this.last.y) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// set timeout for updating plots\r\n+\t\t\tif (this.updateTimeoutHandle) {\r\n+\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n+\t\t\t}\r\n+\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n+\t\t\tthis.currentPath.push(newPoint)\r\n+\t\t\t\r\n+\t\t\tvar dt = newPoint.t - this.last.t;\r\n+\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n+\t\t\tif (dt > 0)\r\n+\t\t\t\tvar speed = dist / dt;\r\n+\t\t\telse\r\n+\t\t\t\tvar speed = 0;\r\n+\t\t\t\r\n+\t\t\ttestAreaSVG.append('line')\r\n+\t\t\t\t// .attr('class', '')\r\n+\t\t\t\t.attr('x1', this.last.x)\r\n+\t\t\t\t.attr('x2', newPoint.x)\r\n+\t\t\t\t.attr('y1', this.last.y)\r\n+\t\t\t\t.attr('y2', newPoint.y)\r\n+\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(5000)\r\n+\t\t\t\t\t.style('stroke-opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\r\n+\t\t\tthis.last = newPoint;\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\taddDataPoint: function(data) {\r\n+\t\t// add point to data array for plotting into ID/time scatter plot\r\n+\t\tif (this.active == false)\r\n+\t\t\treturn;\r\n+\r\n+\t\tvar dt = data.hit.t - data.start.t;\r\n+\t\r\n+\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n+\t\t{\r\n+\t\t\tvar dist = distance(data.target, data.start);\r\n+\t\t\tvar id = shannon(dist, data.target.w);\r\n+\r\n+\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n+\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n+\r\n+\t\t\tscatterGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n+\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n+\t\t\t\t.attr('cx', scatterX(id))\r\n+\t\t\t\t.attr('cy', scatterY(dt))\r\n+\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(200)\r\n+\t\t\t\t\t\t.ease('bounce')\r\n+\t\t\t\t\t\t.attr('r', 3);\t\t\r\n+\t\t\r\n+\t\t\tvar A = data.start;\r\n+\t\t\tvar B = data.target;\r\n+\t\t\tvar path = data.path;\r\n+\t\t\r\n+\t\t\tvar hit = {}\r\n+\t\t\tvar q = project(A, B, data.hit);\r\n+\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n+\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n+\t\t\r\n+\t\t\r\n+\t\t\tplotHitsGroup.append('circle')\r\n+\t\t\t\t.attr('class', 'hit')\r\n+\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n+\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n+\t\t\t\t.attr('r', 6)\r\n+\t\t\t\t.style('fill', 'red')\r\n+\t\t\t\t.style('opacity', 1)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.ease('linear')\r\n+\t\t\t\t\t\t.attr('r', 3);\r\n+\t\t\r\n+\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n+\t\t\tfor (var i = 0; i < path.length; i++) {\r\n+\t\t\t\tvar p = path[i];\r\n+\t\t\t\r\n+\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\tplotPositionGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n+\t\t\t\t\t.attr('x2', scaleX(x))\r\n+\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n+\t\t\t\t\t.attr('y2', scaleY(y))\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n+\t\t\t\t\t.attr('class', 'live')\r\n+\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n+\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n+\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n+\t\t\t\t\t.attr('y2', scaleV(speed))\r\n+\r\n+\t\t\t\t\t.style('stroke', v(speed))\r\n+\t\t\t\t\t.transition()\r\n+\t\t\t\t\t\t.duration(LIVE_STAY)\r\n+\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar last = {}\r\n+\t\t\t\tlast.x = x;\r\n+\t\t\t\tlast.y = y;\r\n+\t\t\t\tlast.t = p.t;\r\n+\t\t\t\tlast.v = speed;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\trandomizeParams: function() {\r\n+\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n+\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n+\r\n+\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n+\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n+\r\n+\t\tthis.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n+\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n+\t},\r\n+\t\r\n+\taddDataSet: function() {\r\n+\t\t\r\n+\t\t// first update the plots\r\n+\t\tthis.updatePlots(this);\r\n+\t\t\r\n+\t\tthis.dataCnt++;\r\n+\t\tvar num = this.dataCnt;\r\n+\t\tvar colour = this.colour(randomAB(0, 10));\r\n+\t\t\r\n+\t\tthis.data[num] = {data: [], colour: colour};\r\n+\t\t\r\n+\t\tthis.currentDataSet = num\r\n+\t\tvar div = d3.select('#dataSets').append('div')\r\n+\t\t\t.attr('id', 'dataSet' + num)\r\n+\t\t\t.text('Data Set ' + num + ' ')\r\n+\t\t\t.style('background-color', colour);\r\n+\t\t\r\n+\t\tvar buttonID ='removeDataSet' + num;\r\n+\t\tdiv.append('button')\r\n+\t\t\t.attr('id', buttonID)\r\n+\t\t\t.attr('type', 'button')\r\n+\t\t\t.text('delete!');\r\n+\t\t\t\r\n+\t\tvar that = this;\r\n+\t\t\r\n+\t\t$('#' + buttonID).click(function() {\r\n+\t\t\tthat.deleteDataSet(num);\r\n+\t\t\tfittsTest.active = false;\r\n+\t\t});\r\n+\t\t\r\n+\t\t$('#dataSet' + num).click(function() {\r\n+\t\t\tif (assIsKey(num, that.data)) {\r\n+\t\t\t\tthat.currentDataSet = num;\r\n+\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\tfittsTest.active = false;\r\n+\r\n+\t\t})\r\n+\t\t\t\r\n+\t\tthis.highlightDataSet(num);\r\n+\t\t// add colour\r\n+\t\t\r\n+\t},\r\n+\t\r\n+\tdeleteDataSet: function(num) {\r\n+\t\tif (assSize(this.data) == 1)\r\n+\t\t{\r\n+\t\t\talert('Cannot delete data set! Create another data set first.')\r\n+\t\t} else\r\n+\t\t{\t\r\n+\t\t\td3.select('#dataSet' + num).remove();\r\n+\t\t\tdelete this.data[num];\r\n+\t\t\t\r\n+\t\t\tscatterGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('r', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.attr('width', 0)\r\n+\t\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\t\r\n+\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n+\t\t\t\t.transition()\r\n+\t\t\t\t\t.duration(500)\r\n+\t\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t\t.remove()\r\n+\t\t\t\r\n+\t\t\tif (num == this.currentDataSet) {\r\n+\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n+\t\t\t\tthis.currentDataSet = first;\r\n+\t\t\t\tthis.highlightDataSet(first);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tthis.updatePlots(this);\r\n+\t\t}\r\n+\t},\r\n+\t\r\n+\thighlightDataSet: function(num) {\r\n+\t\td3.selectAll('#dataSets div')\r\n+\t\t\t.attr('class', '');\r\n+\t\td3.select('#dataSet' + num)\r\n+\t\t\t.attr('class', 'active')\r\n+\t},\r\n+\t\r\n+\tupdatePlots: function(that) {\r\n+\t\t// a little I candy :D\r\n+\t\td3.select('body').append('div')\r\n+\t\t\t.attr('class', 'msg')\r\n+\t\t\t.text('updating plots...')\r\n+\t\t\t.style('opacity', 1)\r\n+\t\t\t.transition()\r\n+\t\t\t\t.duration(2000)\r\n+\t\t\t\t\t.style('opacity', 0)\r\n+\t\t\t\t\t.remove();\r\n+\t\t\t\t\t\r\n+\t\t/* we haven't moven inside the test area, so we can as well disable\r\n+\t\t * the test for now\r\n+\t\t */\r\n+\t\tthat.active = false;\r\n+\r\n+\t\t// for each data set\r\n+\t\t// compute We and IDe and Throughput for each category\r\n+\r\n+\t\t// process data\r\n+\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n+\t\tfor (var key in that.data) { // for each data set\r\n+\t\t\t\r\n+\t\t\tdataSetIndex++;\r\n+\t\t\t\r\n+\t\t\tvar groups = [];\r\n+\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n+\t\t\t\tvar datum = that.data[key].data[i];\r\n+\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n+\t\t\t\tif (!groups[groupID]) {\r\n+\t\t\t\t\tgroups[groupID] = [];\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n+\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n+\t\t\t\t\r\n+\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n+\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n+\t\t\t\tdatum.projectedHitOffsetY = y;\r\n+\t\t\t\t\r\n+\t\t\t\tgroups[groupID].push(datum);\r\n+\t\t\t}\r\n+\r\n+\t\t\tvar newData = [];\r\n+\t\t\tfor (var group in groups) {\r\n+\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n+\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n+\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n+\t\t\t\t\r\n+\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n+\t\t\t\t\tvar datum = groups[group][i];\r\n+\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n+\t\t\t\t\tvar De = dEffective;\r\n+\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n+\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n+\t\t\t\t\tnewData.push(datum);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\r\n+\t\t\t// insert stuff in SVG\r\n+\t\t\tvar colour = that.data[key].colour;\r\n+\t\t\t\r\n+\t\t\tvar insert = function(d) {\r\n+\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n+\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n+\t\t\t\t.attr('r', 5);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n+\t\t\t\t.data(newData);\r\n+\t\t\t\r\n+\t\t\tcircles.enter()\r\n+\t\t\t\t.append('circle')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t\t.style('opacity', 0.5)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\r\n+\t\t\tcircles.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t\t.call(insert);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t// ==================== regression ========================\r\n+\t\t\tvar covTIDe = cov(newData,\r\n+\t\t\t\tfunction(d) { return d.time; },\r\n+\t\t\t\tfunction(d) { return d.IDe});\r\n+\t\t\t\r\n+\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n+\t\t\t\r\n+\t\t\tif (varIDe > 0)\r\n+\t\t\t\tvar b = covTIDe / varIDe;\r\n+\t\t\telse\r\n+\t\t\t\tvar b = 0;\r\n+\t\t\t\r\n+\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n+\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n+\t\t\tvar a = mT - b * mIDe;\r\n+\t\t\t\r\n+\t\t\tif (!isNaN(a))\r\n+\t\t\t{\t\t\t\r\n+\t\t\t\tvar makeLine = function(d) {\r\n+\t\t\t\t\treturn d\r\n+\t\t\t\t\t\t.attr('x1', 0)\r\n+\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n+\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n+\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n+\t\t\t\t}\r\n+\t\t\t\r\n+\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n+\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n+\t\t\t\r\n+\t\t\t\tregression.enter().append('line')\r\n+\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t.style('stroke-width', 2)\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t\r\n+\t\t\t\tregression.transition()\r\n+\t\t\t\t\t.call(makeLine);\r\n+\t\t\t}\r\n+\t\t\t\t\r\n+\r\n+\t\t\t// ============== histogram ====================\r\n+\t\t\tvar histThroughput = d3.layout.histogram()\r\n+\t\t\t\t.bins(20)\r\n+\t\t\t\t.range([0,10])\r\n+\t\t\t\t.value(function(d){return d.throughput;})\r\n+\t\t\t\t\r\n+\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n+\t\t\t\r\n+\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n+\t\t\t\t\t\t\r\n+\t\t\tvar histX = d3.scale.ordinal()\r\n+\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n+\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n+\t\r\n+\t\t\tvar histY = d3.scale.linear()\r\n+\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n+\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n+\t\t\t\t\r\n+\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n+\t\t\t\t.data(throughputHistogramData);\r\n+\t\t\t\t\r\n+\t\t\t\r\n+\t\t\tvar numDataSets = assSize(that.data);\r\n+\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n+\t\t\t\r\n+\t\t\tvar makeRect = function(d) {\r\n+\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n+\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n+\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n+\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tvar histXAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histX)\r\n+\t\t\t\t.ticks(2);\r\n+\r\n+\t\t\tvar histYAxis = d3.svg.axis()\r\n+\t\t\t\t.scale(histY)\r\n+\t\t\t\t.ticks(5)\r\n+\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n+\t\t\t\r\n+\t\t\tthroughputGroup.append(\"g\")\r\n+\t\t\t\t.attr(\"class\", \"axis\")\r\n+\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n+\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n+\t\r\n+\t\t\t// throughputGroup.append(\"g\")\r\n+\t\t\t\t// .attr(\"class\", \"axis\")\r\n+\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n+\t\t\t\r\n+\t\t\tthroughputRect.enter()\r\n+\t\t\t\t.append('rect')\r\n+\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t.attr('rx', 2)\r\n+\t\t\t\t.attr('ry', 2)\r\n+\t\t\t\t.style('fill', colour)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\tthroughputRect.transition()\r\n+\t\t\t\t.duration(500)\r\n+\t\t\t\t.call(makeRect)\r\n+\t\t\t\t\r\n+\t\t\t// ==================== eff position and speed ===================\r\n+\t\t\t// more or less copy-pasted from above\r\n+\t\t\tfor (var i = 0; i < newData.length; i++)\r\n+\t\t\t{\r\n+\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n+\t\t\t\tvar A = newData[i].start;\r\n+\t\t\t\tvar B = newData[i].target\r\n+\t\t\t\tvar dAB = distance(A, B);\r\n+\t\t\t\tvar offset = newData[i].distance - dAB;\r\n+\t\t\t\toffset = 0;\r\n+\t\t\t\t\t\t\t\t\r\n+\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n+\t\t\t\t{\r\n+\r\n+\t\t\t\t\tvar p = newData[i].path[j];\r\n+\t\t\t\r\n+\t\t\t\t\tvar q = project(A, B, p);\r\n+\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n+\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n+\r\n+\t\t\t\t\tvar dt = p.t - last.t;\r\n+\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n+\t\t\t\t\tif (dt > 0)\r\n+\t\t\t\t\t\tvar speed = dist / dt;\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t\tvar speed = 0;\r\n+\t\t\r\n+\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n+\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n+\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n+\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\r\n+\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n+\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n+\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n+\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n+\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n+\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n+\t\t\t\t\t\t.style('stroke', colour)\r\n+\t\t\t\t\t\t.style('opacity', 0.5);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tvar last = {}\r\n+\t\t\t\t\tlast.x = x;\r\n+\t\t\t\t\tlast.y = y;\r\n+\t\t\t\t\tlast.t = p.t;\r\n+\t\t\t\t\tlast.v = speed;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\t\t\r\n+\t}\r\n+};\r\n+\r\n+// _empirical_ covariance\r\n+function cov(data, extractorA, extractorB) {\r\n+\t\r\n+\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tvar mA = mean(data, extractorA);\r\n+\tvar mB = mean(data, extractorB);\r\n+\t\r\n+\tvar cov = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n+\t}\r\n+\t\r\n+\treturn cov / (data.length - 1);\r\n+}\r\n+\r\n+function variance(data, extractor) {\r\n+\treturn cov(data, extractor, extractor);\r\n+}\r\n+\r\n+function mean(data, extractor) {\r\n+\tvar sum = 0;\r\n+\tfor (var i = 0; i < data.length; i++) {\r\n+\t\tsum += extractor(data[i]);\r\n+\t}\r\n+\treturn sum / data.length;\r\n+}\r\n+\r\n+function randomAB(a, b) {\r\n+\treturn a + Math.random() * (b - a);\r\n+}\r\n+\r\n+function assSize(assArr) {\r\n+\tvar size = 0;\r\n+\tfor (var _ in assArr) {\r\n+\t\tsize++;\r\n+\t}\r\n+\treturn size;\r\n+}\r\n+\r\n+function assFirstKey(assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\treturn key;\r\n+\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+function assIsKey(needle, assArr) {\r\n+\tfor (var key in assArr) {\r\n+\t\tif (needle == key) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t}\r\n+\treturn false;\r\n+}\r\n+\r\n+\r\n+/**\r\n+ * Project a point q onto the line p0-p1\r\n+ * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n+ */\r\n+function project(A, B, p) {\r\n+\tvar AB = minus(B, A);\r\n+\tvar AB_squared = dot(AB, AB);\r\n+\tif (AB_squared == 0) {\r\n+\t\treturn A;\r\n+\t}\r\n+\telse {\r\n+\t\tvar Ap = minus(p, A);\r\n+\t\tvar t = dot(Ap, AB) / AB_squared;\r\n+\t\treturn {x: A.x + t * AB.x,\r\n+\t\t\t\ty: A.y + t * AB.y,\r\n+\t\t\t\tt: t};\r\n+\t}\r\n+}\r\n+\r\n+\r\n+\r\n+function mouseMoved()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseMoved(m[0], m[1])\r\n+}\r\n+\r\n+function mouseClicked()\r\n+{\r\n+\tvar m = d3.svg.mouse(this);\r\n+\tfittsTest.mouseClicked(m[0], m[1]);\r\n+}\r\n+\r\n+function dot(a, b) {\r\n+\treturn (a.x * b.x) + (a.y * b.y);\r\n+}\r\n+\r\n+// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n+function isLeft(A, B, p){\r\n+     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n+}\r\n+\r\n+function minus(a, b) {\r\n+\treturn {x: a.x - b.x, y: a.y - b.y};\r\n+}\r\n+\r\n+function distance(a, b) {\r\n+\tvar dx = a.x - b.x;\r\n+\tvar dy = a.y - b.y;\r\n+\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n+}\r\n+\r\n+function sign(a) {\r\n+\treturn a >=0 ? 1 : -1;\r\n+}\r\n+\r\n+function rgb2Hex(r, g, b) {\r\n+\treturn '#' +\r\n+\t\tclampInt(0, 255, r).toString(16) +\r\n+\t\tclampInt(0, 255, g).toString(16) +\r\n+\t\tclampInt(0, 255, b).toString(16);\r\n+}\r\n+\r\n+function clampInt(lower, upper, x) {\r\n+\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n+}\r\n+\r\n+function shannon(A, W) {\r\n+\treturn Math.log(A / W + 1) / Math.log(2);\r\n+}\r\n+\r\n+function bgRect(d, dim) {\r\n+\treturn d.append('rect')\r\n+\t\t.attr('cx', 0)\r\n+\t\t.attr('cy', 0)\r\n+\t\t.attr('width', dim.width)\r\n+\t\t.attr('height', dim.height)\r\n+\t\t.attr('class', 'back');\r\n+}\r\n+\r\n+\r\n+\r\n+var testAreaSVG = d3.select('#test-area').append('svg')\r\n+\t.attr('width', testDimension.width)\r\n+\t.attr('height', testDimension.height)\r\n+\t.style('pointer-events', 'all')\r\n+    .on('mousemove', mouseMoved)\r\n+\t.on('mousedown', mouseClicked)\r\n+\t.call(bgRect, testDimension);\r\n+\r\n+var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n+\t.attr('width', plotPositionDimension.width)\r\n+\t.attr('height', plotPositionDimension.height)\r\n+\t.call(bgRect, plotPositionDimension)\r\n+\r\n+var plotPositionGroup = plotPositionSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n+\r\n+var positionXAxis = d3.svg.axis()\r\n+\t.scale(scaleX)\r\n+\t.ticks(7)\r\n+var positionYAxis = d3.svg.axis()\r\n+\t.scale(scaleY)\r\n+\t.ticks(6)\r\n+\t\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n+plotPositionGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\r\n+\t\r\n+\r\n+\r\n+var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n+\t.attr('width', plotHitsDimension.width)\r\n+\t.attr('height', plotHitsDimension.height)\r\n+\t.call(bgRect, plotHitsDimension);\r\n+\r\n+\r\n+var plotHitsGroup = plotHitsSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n+plotHitsGroup.append('circle')\r\n+\t.attr('cx', 0)\r\n+\t.attr('cy', 0)\r\n+\t.attr('r', plotHitsDimension.innerWidth/2)\r\n+\t.style('opacity', 0.1)\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -plotHitsDimension.cx)\r\n+\t.attr('y2', 0);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', -10);\r\n+plotHitsGroup.append('line')\r\n+\t.attr('x1', 0)\r\n+\t.attr('y1', 0)\r\n+\t.attr('x2', -10)\r\n+\t.attr('y2', 10);\r\n+\r\n+\t\r\n+\t\r\n+var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n+\t.attr('width', plotVelocitiesDimension.width)\r\n+\t.attr('height', plotVelocitiesDimension.height)\r\n+\t.call(bgRect, plotVelocitiesDimension);\r\n+\r\n+var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n+\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n+\r\n+var speedXAxis = d3.svg.axis()\r\n+\t.scale(scaleT)\r\n+\t.ticks(7)\r\n+var speedYAxis = d3.svg.axis()\r\n+\t.scale(scaleV)\r\n+\t.ticks(6)\r\n+\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n+\t// .append('text')\r\n+\t// \t.text('time in ms')\r\n+\t// \t.attr('x', 80)\r\n+\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n+\t// \t.style('text-anchor', 'middle');\r\n+\t\t\r\n+plotVelocitiesGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('pixel/ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 80)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+\r\n+var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n+\t.attr('width', plotScatterDimension.width)\r\n+\t.attr('height', plotScatterDimension.height)\r\n+\t.call(bgRect, plotScatterDimension);\r\n+\r\n+var scatterGroup = scatterSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var xAxis = d3.svg.axis()\r\n+\t.scale(scatterX)\r\n+\t.ticks(7)\r\n+\t.tickSize(6, 3, 0);\r\n+var yAxis = d3.svg.axis()\r\n+\t.scale(scatterY)\r\n+\t.ticks(6)\r\n+\t.tickSize(6, 3, 6)\r\n+\t\r\n+// print axes\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('ID')\r\n+\t\t// \t.attr('x', 80)\r\n+\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+scatterGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n+\t\t// .append('text')\r\n+\t\t// \t.text('time in ms')\r\n+\t\t// \t.attr('x', -20)\r\n+\t\t// \t.attr('y', 65)\r\n+\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n+\t\t// \t.style('text-anchor', 'middle');\r\n+\r\n+\r\n+\r\n+var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n+\t.attr('width', scatterEffectiveDimension.width)\r\n+\t.attr('height', scatterEffectiveDimension.height)\r\n+\t.call(bgRect, scatterEffectiveDimension);\r\n+\r\n+var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n+\r\n+// define Axes.\r\n+var effXAxis = d3.svg.axis()\r\n+\t.scale(effScatterX)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 0);\r\n+\r\n+var effYAxis = d3.svg.axis()\r\n+\t.scale(effScatterY)\r\n+\t.ticks(10)\r\n+\t.tickSize(6, 3, 6)\r\n+\r\n+\r\n+// print axes\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n+\r\n+scatterEffectiveGroup.append(\"g\")\r\n+    .attr(\"class\", \"axis\")\r\n+\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n+    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n+\r\n+var throughputSVG = d3.select('#throughput').append('svg')\r\n+\t.attr('width', histDimension.width)\r\n+\t.attr('height', histDimension.height)\r\n+\t.call(bgRect, histDimension);\r\n+\r\n+var throughputGroup = throughputSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n+\r\n+//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n+\r\n+\t\r\n+\r\n+var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n+\t.attr('width', positionEffectiveDimension.width)\r\n+\t.attr('height', positionEffectiveDimension.height)\r\n+\t.call(bgRect, positionEffectiveDimension);\r\n+\r\n+var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n+\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n+\r\n+var positionEffXAxis = d3.svg.axis()\r\n+\t.scale(effPositionX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n+\r\n+var positionEffYAxis = d3.svg.axis()\r\n+\t.scale(effPositionY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n+\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n+\t.call(positionEffXAxis.orient('bottom'));\r\n+\t\r\n+positionEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t\t.call(positionEffYAxis.orient('left'));\t\r\n+\t\r\n+\t\r\n+\t\r\n+\r\n+var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n+\t.attr('width', speedEffectiveDimension.width)\r\n+\t.attr('height', speedEffectiveDimension.height)\r\n+\t.call(bgRect, speedEffectiveDimension);\r\n+\r\n+var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n+\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n+\r\n+var speedEffXAxis = d3.svg.axis()\r\n+\t.scale(effSpeedX)\r\n+\t.ticks(10)\r\n+\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n+\r\n+var speedEffYAxis = d3.svg.axis()\r\n+\t.scale(effSpeedY)\r\n+\t.ticks(5)\r\n+\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n+\t.call(speedEffXAxis.orient('bottom'));\r\n+\r\n+speedEffectiveGroup.append('g')\r\n+\t.attr('class', 'axis')\r\n+\t.call(speedEffYAxis.orient('left'));\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+// init code\r\n+// should probably go somewhere else though. \r\n+fittsTest.active = false;\r\n+fittsTest.generateISOPositions(15, 150, 10);\r\n+fittsTest.updateISOCircles();\r\n+d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n+d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n+fittsTest.addDataSet();\r\n+\r\n+// setup sliders\r\n+$(\"#sliderDistance\").slider({\r\n+\tmin: fittsTest.isoLimits.minD,\r\n+\tmax: fittsTest.isoLimits.maxD,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.distance,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.distance = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$(\"#sliderWidth\").slider({\r\n+\tmin: fittsTest.isoLimits.minW,\r\n+\tmax: fittsTest.isoLimits.maxW,\r\n+\tstep: 1,\r\n+\tvalue: fittsTest.isoParams.width,\r\n+\tslide: function(event, ui) {\r\n+\t\tfittsTest.isoParams.width = ui.value;\r\n+\t\tfittsTest.updateISOCircles();\r\n+\t\td3.select('#sliderWidthValue').text(ui.value);\r\n+\t\t$('#randomizeCheckbox').attr('checked', false);\r\n+\t\tfittsTest.isoParams.randomize = false;\r\n+\t}\r\n+});\r\n+\r\n+$('#randomizeButton').click(function() {\r\n+\tfittsTest.randomizeParams();\r\n+\t$('#randomizeCheckbox').attr('checked', true);\r\n+\tfittsTest.isoParams.randomize = true;\r\n+});\r\n+\r\n+$('#randomizeCheckbox').change(function(event) {\r\n+\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n+})\r\n+\r\n+$('#addDataSetButton').click(function() {\r\n+\tfittsTest.addDataSet();\r\n+\tfittsTest.active = false;\r\n+\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n+});\r\n+\r\n+\r\n+function toCsv(arr) {\r\n+    return arr.map( row => \r\n+        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n+    ).join('\\n');\r\n+}\r\n+\r\n+function downloadBlob(content, filename, contentType) {\r\n+\t// Create a blob\r\n+\tvar blob = new Blob([content], { type: contentType });\r\n+\tvar url = URL.createObjectURL(blob);\r\n+  \r\n+\t// Create a link to download it\r\n+\tvar pom = document.createElement('a');\r\n+\tpom.href = url;\r\n+\tpom.setAttribute('download', filename);\r\n+\tpom.click();\r\n+}\r\n+\r\n+\r\n+$('#downloadDataButton').click(function() {\r\n+\tlet i = 1;\r\n+\t// let newData = []\r\n+\r\n+\t// while (i <= fittsTest.dataCnt - 1) {\r\n+    // \tlet j = 0;\r\n+\t// \twhile (j <= fittsTest.data[i].data.length - 1) {\r\n+\t// \t\tnewData.push({i : fittsTest.data[i].data[j]});\r\n+\t// \t\tj++;\r\n+\t// \t}\r\n+\t// \ti++;\r\n+\t// }\r\n+\r\n+\t// console.log(newData);\r\n+\t// let csv = toCsv(newData);\r\n+\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n+\tdownloadBlob(JSON.stringify(fittsTest), 'export.json', 'text/json;charset=utf-8;')\r\n+\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686113645412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1235,37316 +1235,7 @@\n \r\n \t// console.log(newData);\r\n \t// let csv = toCsv(newData);\r\n \t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\tdownloadBlob(JSON.stringify(fittsTest), 'export.json', 'text/json;charset=utf-8;')\r\n+\tdownloadBlob(JSON.stringify(fittsTest.data), 'export.json', 'text/json;charset=utf-8;')\r\n \r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n-});\r\n-\r\n-\r\n-function toCsv(arr) {\r\n-    return arr.map( row => \r\n-        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n-    ).join('\\n');\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\t// let newData = []\r\n-\r\n-\t// while (i <= fittsTest.dataCnt - 1) {\r\n-    // \tlet j = 0;\r\n-\t// \twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t// \t\tnewData.push({i : fittsTest.data[i].data[j]});\r\n-\t// \t\tj++;\r\n-\t// \t}\r\n-\t// \ti++;\r\n-\t// }\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = toCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n-});\r\n-\r\n-\r\n-function toCsv(arr) {\r\n-    return arr.map( row => \r\n-        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n-    ).join('\\n');\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = toCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-// function pivot(arr) {\r\n-//     var mp = new Map();\r\n-    \r\n-//     function setValue(a, path, val) {\r\n-//         if (Object(val) !== val) { // primitive value\r\n-//             var pathStr = path.join('.');\r\n-//             var i = (mp.has(pathStr) ? mp : mp.set(pathStr, mp.size)).get(pathStr);\r\n-//             a[i] = val;\r\n-//         } else {\r\n-//             for (var key in val) {\r\n-//                 setValue(a, key == '0' ? path : path.concat(key), val[key]);\r\n-//             }\r\n-//         }\r\n-//         return a;\r\n-//     }\r\n-    \r\n-//     var result = arr.map( obj => setValue([], [], obj) );\r\n-//     return [[...mp.keys()], ...result];\r\n-// }\r\n-\r\n-function toCsv(arr) {\r\n-    return arr.map( row => \r\n-        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n-    ).join('\\n');\r\n-}\r\n-\r\n-// function arrayToCsv(data){\r\n-// \treturn data.map(row =>\r\n-// \t  row\r\n-// \t  .map(String)  // convert every value to String\r\n-// \t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-// \t  .map(v => `\"${v}\"`)  // quote it\r\n-// \t  .join(',')  // comma-separated\r\n-// \t).join('\\r\\n');  // rows starting on new lines\r\n-// }\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = toCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function pivot(arr) {\r\n-    var mp = new Map();\r\n-    \r\n-    function setValue(a, path, val) {\r\n-        if (Object(val) !== val) { // primitive value\r\n-            var pathStr = path.join('.');\r\n-            var i = (mp.has(pathStr) ? mp : mp.set(pathStr, mp.size)).get(pathStr);\r\n-            a[i] = val;\r\n-        } else {\r\n-            for (var key in val) {\r\n-                setValue(a, key == '0' ? path : path.concat(key), val[key]);\r\n-            }\r\n-        }\r\n-        return a;\r\n-    }\r\n-    \r\n-    var result = arr.map( obj => setValue([], [], obj) );\r\n-    return [[...mp.keys()], ...result];\r\n-}\r\n-\r\n-function toCsv(arr) {\r\n-    return arr.map( row => \r\n-        row.map ( val => isNaN(val) ? JSON.stringify(val) : +val ).join(',')\r\n-    ).join('\\n');\r\n-}\r\n-\r\n-// function arrayToCsv(data){\r\n-// \treturn data.map(row =>\r\n-// \t  row\r\n-// \t  .map(String)  // convert every value to String\r\n-// \t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-// \t  .map(v => `\"${v}\"`)  // quote it\r\n-// \t  .join(',')  // comma-separated\r\n-// \t).join('\\r\\n');  // rows starting on new lines\r\n-// }\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = toCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(filename, rows) {\r\n-\tvar processRow = function (row) {\r\n-        var finalVal = '';\r\n-        for (var j = 0; j < row.length; j++) {\r\n-            var innerValue = row[j] === null ? '' : row[j].toString();\r\n-            if (row[j] instanceof Date) {\r\n-                innerValue = row[j].toLocaleString();\r\n-            };\r\n-            var result = innerValue.replace(/\"/g, '\"\"');\r\n-            if (result.search(/(\"|,|\\n)/g) >= 0)\r\n-                result = '\"' + result + '\"';\r\n-            if (j > 0)\r\n-                finalVal += ',';\r\n-            finalVal += result;\r\n-        }\r\n-        return finalVal + '\\n';\r\n-    };\r\n-\r\n-    var csvFile = '';\r\n-    for (var i = 1; i < rows.length; i++) {\r\n-        csvFile += processRow(rows[i]);\r\n-    }\r\n-\r\n-    var blob = new Blob([csvFile], { type: 'text/csv;charset=utf-8;' });\r\n-    if (navigator.msSaveBlob) { // IE 10+\r\n-        navigator.msSaveBlob(blob, filename);\r\n-    } else {\r\n-        var link = document.createElement(\"a\");\r\n-        if (link.download !== undefined) { // feature detection\r\n-            // Browsers that support HTML5 download attribute\r\n-            var url = URL.createObjectURL(blob);\r\n-            link.setAttribute(\"href\", url);\r\n-            link.setAttribute(\"download\", filename);\r\n-            link.style.visibility = 'hidden';\r\n-            document.body.appendChild(link);\r\n-            link.click();\r\n-            document.body.removeChild(link);\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-// function downloadBlob(content, filename, contentType) {\r\n-// \t// Create a blob\r\n-// \tvar blob = new Blob([content], { type: contentType });\r\n-// \tvar url = URL.createObjectURL(blob);\r\n-  \r\n-// \t// Create a link to download it\r\n-// \tvar pom = document.createElement('a');\r\n-// \tpom.href = url;\r\n-// \tpom.setAttribute('download', filename);\r\n-// \tpom.click();\r\n-// }\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(filename, rows) {\r\n-\tvar processRow = function (row) {\r\n-        var finalVal = '';\r\n-        for (var j = 0; j < row.length; j++) {\r\n-            var innerValue = row[j] === null ? '' : row[j].toString();\r\n-            if (row[j] instanceof Date) {\r\n-                innerValue = row[j].toLocaleString();\r\n-            };\r\n-            var result = innerValue.replace(/\"/g, '\"\"');\r\n-            if (result.search(/(\"|,|\\n)/g) >= 0)\r\n-                result = '\"' + result + '\"';\r\n-            if (j > 0)\r\n-                finalVal += ',';\r\n-            finalVal += result;\r\n-        }\r\n-        return finalVal + '\\n';\r\n-    };\r\n-\r\n-    var csvFile = '';\r\n-    for (var i = 0; i < rows.length; i++) {\r\n-        csvFile += processRow(rows[i]);\r\n-    }\r\n-\r\n-    var blob = new Blob([csvFile], { type: 'text/csv;charset=utf-8;' });\r\n-    if (navigator.msSaveBlob) { // IE 10+\r\n-        navigator.msSaveBlob(blob, filename);\r\n-    } else {\r\n-        var link = document.createElement(\"a\");\r\n-        if (link.download !== undefined) { // feature detection\r\n-            // Browsers that support HTML5 download attribute\r\n-            var url = URL.createObjectURL(blob);\r\n-            link.setAttribute(\"href\", url);\r\n-            link.setAttribute(\"download\", filename);\r\n-            link.style.visibility = 'hidden';\r\n-            document.body.appendChild(link);\r\n-            link.click();\r\n-            document.body.removeChild(link);\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-// function downloadBlob(content, filename, contentType) {\r\n-// \t// Create a blob\r\n-// \tvar blob = new Blob([content], { type: contentType });\r\n-// \tvar url = URL.createObjectURL(blob);\r\n-  \r\n-// \t// Create a link to download it\r\n-// \tvar pom = document.createElement('a');\r\n-// \tpom.href = url;\r\n-// \tpom.setAttribute('download', filename);\r\n-// \tpom.click();\r\n-// }\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tlet csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\tvar processRow = function (row) {\r\n-        var finalVal = '';\r\n-        for (var j = 0; j < row.length; j++) {\r\n-            var innerValue = row[j] === null ? '' : row[j].toString();\r\n-            if (row[j] instanceof Date) {\r\n-                innerValue = row[j].toLocaleString();\r\n-            };\r\n-            var result = innerValue.replace(/\"/g, '\"\"');\r\n-            if (result.search(/(\"|,|\\n)/g) >= 0)\r\n-                result = '\"' + result + '\"';\r\n-            if (j > 0)\r\n-                finalVal += ',';\r\n-            finalVal += result;\r\n-        }\r\n-        return finalVal + '\\n';\r\n-    };\r\n-\r\n-    var csvFile = '';\r\n-    for (var i = 0; i < rows.length; i++) {\r\n-        csvFile += processRow(rows[i]);\r\n-    }\r\n-\r\n-    var blob = new Blob([csvFile], { type: 'text/csv;charset=utf-8;' });\r\n-    if (navigator.msSaveBlob) { // IE 10+\r\n-        navigator.msSaveBlob(blob, filename);\r\n-    } else {\r\n-        var link = document.createElement(\"a\");\r\n-        if (link.download !== undefined) { // feature detection\r\n-            // Browsers that support HTML5 download attribute\r\n-            var url = URL.createObjectURL(blob);\r\n-            link.setAttribute(\"href\", url);\r\n-            link.setAttribute(\"download\", filename);\r\n-            link.style.visibility = 'hidden';\r\n-            document.body.appendChild(link);\r\n-            link.click();\r\n-            document.body.removeChild(link);\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-// function downloadBlob(content, filename, contentType) {\r\n-// \t// Create a blob\r\n-// \tvar blob = new Blob([content], { type: contentType });\r\n-// \tvar url = URL.createObjectURL(blob);\r\n-  \r\n-// \t// Create a link to download it\r\n-// \tvar pom = document.createElement('a');\r\n-// \tpom.href = url;\r\n-// \tpom.setAttribute('download', filename);\r\n-// \tpom.click();\r\n-// }\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\tcsv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 1;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 1;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++;\r\n-\t\t}\r\n-\t\ti++;\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tj++\r\n-\t\t}\r\n-\t\ti++\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\tj++\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t\ti++\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t\ti++\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1])\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length - 1) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length) {\r\n-\t\t\tconsole.log(fittsTest.data[i].data[j]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length) {\r\n-\t\t\tconsole.log([i, fittsTest.data[i].data[j]]);\r\n-\t\t\t// newData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// console.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length) {\r\n-\t\t\tconsole.log([i, fittsTest.data[i].data[j]]);\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= fittsTest.data[i].data.length) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tlet j = 0;\r\n-\t\twhile (j <= lengthfittsTest.data[i].data.length) {\r\n-\t\t\tnewData.push([i, fittsTest.data[i].data[j]]);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tnewData.push(fittsTest.data[i])\r\n-    \ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tnewData.push(fittsTest.data[i])\r\n-    \ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tnewData.push(fittsTest.data[i].data)\r\n-    \ti++;\r\n-\t}\r\n-\r\n-\tconsole.log(newData);\r\n-\r\n-\t// let csv = arrayToCsv(newData);\r\n-\t// downloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-function arrayToCsv(data){\r\n-\treturn data.map(row =>\r\n-\t  row\r\n-\t  .map(String)  // convert every value to String\r\n-\t  .map(v => v.replaceAll('\"', '\"\"'))  // escape double colons\r\n-\t  .map(v => `\"${v}\"`)  // quote it\r\n-\t  .join(',')  // comma-separated\r\n-\t).join('\\r\\n');  // rows starting on new lines\r\n-}\r\n-\r\n-function downloadBlob(content, filename, contentType) {\r\n-\t// Create a blob\r\n-\tvar blob = new Blob([content], { type: contentType });\r\n-\tvar url = URL.createObjectURL(blob);\r\n-  \r\n-\t// Create a link to download it\r\n-\tvar pom = document.createElement('a');\r\n-\tpom.href = url;\r\n-\tpom.setAttribute('download', filename);\r\n-\tpom.click();\r\n-}\r\n-\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tlet i = 0;\r\n-\tlet newData = []\r\n-\r\n-\twhile (i <= fittsTest.dataCnt - 1) {\r\n-    \tnewData.push(fittsTest.data[i].data)\r\n-    \ti++;\r\n-\t}\r\n-\r\n-\tlet csv = arrayToCsv(newData);\r\n-\tdownloadBlob(csv, 'export.csv', 'text/csv;charset=utf-8;')\r\n-\t\r\n-});\n-\"use strict\";\r\n-\r\n-// import { JsonArray, download } from 'json-to-csv-in-browser'\r\n-\r\n-/**\r\n- * Create dimensions from the given values and store them for later use.\r\n- * All values should be positive and make sense.\r\n- * @param {number} width The outer width of the area.\r\n- * @param {number} height The outer height of the area.\r\n- * @param {number} top Margin form the top edge.\r\n- * @param {number} right Margin form the right edge.\r\n- * @param {number} bottom Margin form the bottom edge.\r\n- * @param {number} left Margin form the left edge.\r\n- */\r\n-function makeDimension(width, height, top, right, bottom, left) {\r\n-\treturn {width: width,\r\n-\t\theight: height,\r\n-\t\tinnerWidth: width - (left + right),\r\n-\t\tinnerHeight: height - (top + bottom),\r\n-\t\ttop: top,\r\n-\t\tright: right,\r\n-\t\tbottom: bottom,\r\n-\t\tleft: left,\r\n-\t\tcx: (width - (left + right)) / 2 + left,\r\n-\t\tcy: (height - (top + bottom)) / 2 + top};\r\n-}\r\n-\r\n-// set up dimensions for the plotting.\r\n-var testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\n-var plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\n-var plotVelocitiesDimension = plotPositionDimension;\r\n-var plotHitsDimension = plotPositionDimension;\r\n-var plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\n-var scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-var positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\n-var speedEffectiveDimension = positionEffectiveDimension;\r\n-var histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n-\r\n-var LIVE_STAY = 1000;\r\n-var MAX_TIME = 2000;\r\n-var UPDATE_DELAY = MAX_TIME;\r\n-var MAX_SPEED = 6; // pixel/ms\r\n-\r\n-function rHit(r, rTarget) {\r\n-\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n-};\r\n-\r\n-\r\n-\r\n-function v(v) {\r\n-\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n-\treturn colour;\r\n-};\r\n-\r\n-var scatterX = d3.scale.linear()\r\n-\t.domain([0.5, 5.5])\r\n-\t.range([0, plotScatterDimension.innerWidth]);\r\n-\r\n-var scatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, plotScatterDimension.innerHeight]);\r\n-\r\n-var scaleT = d3.scale.linear()\r\n-\t.domain([0, 1000])\r\n-\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n-\r\n-var scaleV = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n-\r\n-var scaleX = d3.scale.linear()\r\n-\t.domain([-20, 300])\r\n-\t.range([0, plotPositionDimension.innerWidth]);\r\n-\r\n-var scaleY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([plotPositionDimension.innerHeight, 0]);\r\n-\r\n-var effScatterX = d3.scale.linear()\r\n-\t.domain([0.5, 6.5])\r\n-\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n-\r\n-var effScatterY = d3.scale.linear()\r\n-\t.domain([MAX_TIME, 0])\r\n-\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n-\r\n-var effPositionX = d3.scale.linear()\r\n-\t.domain([-60, 400])\r\n-\t.range([0, positionEffectiveDimension.innerWidth]);\r\n-\r\n-var effPositionY = d3.scale.linear()\r\n-\t.domain([-50, 50])\r\n-\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n-\t\r\n-var effSpeedX = d3.scale.linear()\r\n-\t.domain([0, MAX_TIME])\r\n-\t.range([0, speedEffectiveDimension.innerWidth])\r\n-\r\n-var effSpeedY = d3.scale.linear()\r\n-\t.domain([0, MAX_SPEED])\r\n-\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n-\r\n-\r\n-\r\n-var fittsTest = {\r\n-\ttarget: {x: 0, y: 0, r: 10},\r\n-\tstart: {x: 0, y: 0, t: 0},\r\n-\tlast: {},\r\n-\r\n-\tisoPositions: [],\r\n-\tcurrentPosition: 0,\r\n-\tcurrentCount: 0,\r\n-\tmiss: 0,\r\n-\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n-\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n-\t\r\n-\tcurrentPath: [],\r\n-\tactive: false,\r\n-\t\r\n-\tdata: [],\r\n-\tcurrentDataSet: 0,\r\n-\tdataCnt: 0,\r\n-\t\r\n-\tcolour: d3.scale.category10(),\r\n-\t\r\n-\tsumID: 0,\r\n-\tsumTime: 0,\r\n-\t\r\n-\tupdateTimeoutHandle: undefined,\r\n-\t\r\n-\tgenerateTarget: function() {\r\n-\t\tthis.target = this.isoPositions[this.currentPosition];\r\n-\t\tthis.target.distance = this.isoParams.distance;\r\n-\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n-\t\t\r\n-\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\ttarget.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('id', 'target')\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\ttarget.transition()\r\n-\t\t\t\t.call(insert);\r\n-\r\n-\t\t\r\n-\t\tthis.active = true;\r\n-\t},\r\n-\t\r\n-\tupdateISOCircles: function() {\r\n-\t\tthis.currentCount = 0;\r\n-\t\t\r\n-\t\tthis.generateISOPositions(this.isoParams.num,\r\n-\t\t\tthis.isoParams.distance,\r\n-\t\t\tthis.isoParams.width);\r\n-\r\n-\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n-\t\t\r\n-\t\tvar insert = function(d) {\r\n-\t\t\td.attr('cx', function(d) { return d.x; })\r\n-\t\t\t.attr('cy', function(d) { return d.y; })\r\n-\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n-\t\t}\r\n-\r\n-\t\tcircles.enter()\r\n-\t\t\t.append('circle')\r\n-\t\t\t\t.attr('class', 'iso')\r\n-\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\t\t\t\t\r\n-\t\tcircles.transition()\r\n-\t\t\t.call(insert);\r\n-\t\t\r\n-\t\tcircles.exit()\r\n-\t\t\t.transition()\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.currentPosition = 0;\r\n-\t\tthis.generateTarget();\r\n-\t\tthis.active = false;\r\n-},\r\n-\t\r\n-\tgenerateISOPositions: function(num, d, w) {\r\n-\t\t\r\n-\t\t// remove all data from live view\r\n-\t\tplotHitsGroup.selectAll('circle.hit')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t.attr('r', 2)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\r\n-\t\tplotPositionGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\r\n-\t\tplotVelocitiesGroup.selectAll('line.live')\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t.remove();\r\n-\t\t\r\n-\t\t\r\n-\t\tthis.isoPositions = [];\r\n-\t\t\r\n-\t\tfor (var i = 0; i < num; i++) {\r\n-\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n-\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n-\t\t\t\tw: w};\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tremoveTarget: function() {\r\n-\t\ttestAreaSVG.selectAll('#target').data([])\r\n-\t\t\t.exit()\r\n-\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\tthis.active = false;\r\n-\t\tthis.currentPath = [];\r\n-\t},\r\n-\t\r\n-\tmouseClicked: function(x, y) {\r\n-\t\t\r\n-\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n-\t\t\tthis.addDataPoint({start: this.start,\r\n-\t\t\t\t\t\t\t   target: this.target,\r\n-\t\t\t\t\t\t\t   path: this.currentPath,\r\n-\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n-\t\t\tthis.removeTarget();\r\n-\r\n-\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n-\t\t\t\tthis.randomizeParams();\r\n-\t\t\t\tthis.currentCount = 0;\r\n-\t\t\t\tthis.currentPosition = 0;\r\n-\t\t\t\tthis.miss = 0;\r\n-\t\t\t\tthis.updateISOCircles;\r\n-\t\t\t\tthis.generateTarget();\r\n-\t\t\t\tthis.active = false;\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tthis.currentCount++;\r\n-\t\t\t\tthis.generateTarget();\t\t\t\r\n-\t\t\t}\r\n-\r\n-\t\t\t\r\n-\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n-\t\t\tthis.start = this.last;\r\n-\t\t\tthis.currentPath.push(this.last);\r\n-\t\t}\r\n-\t\telse {\r\n-\t\t\tthis.miss++;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\tmouseMoved: function(x, y) {\r\n-\t\tif (this.active) {\r\n-\t\t\t// skip if the mouse did actually not move\r\n-\t\t\t// that should practically never happen...\r\n-\t\t\tif (x == this.last.x && y == this.last.y) {\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t// set timeout for updating plots\r\n-\t\t\tif (this.updateTimeoutHandle) {\r\n-\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n-\t\t\t}\r\n-\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n-\t\t\tthis.currentPath.push(newPoint)\r\n-\t\t\t\r\n-\t\t\tvar dt = newPoint.t - this.last.t;\r\n-\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n-\t\t\tif (dt > 0)\r\n-\t\t\t\tvar speed = dist / dt;\r\n-\t\t\telse\r\n-\t\t\t\tvar speed = 0;\r\n-\t\t\t\r\n-\t\t\ttestAreaSVG.append('line')\r\n-\t\t\t\t// .attr('class', '')\r\n-\t\t\t\t.attr('x1', this.last.x)\r\n-\t\t\t\t.attr('x2', newPoint.x)\r\n-\t\t\t\t.attr('y1', this.last.y)\r\n-\t\t\t\t.attr('y2', newPoint.y)\r\n-\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(5000)\r\n-\t\t\t\t\t.style('stroke-opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\r\n-\t\t\tthis.last = newPoint;\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\taddDataPoint: function(data) {\r\n-\t\t// add point to data array for plotting into ID/time scatter plot\r\n-\t\tif (this.active == false)\r\n-\t\t\treturn;\r\n-\r\n-\t\tvar dt = data.hit.t - data.start.t;\r\n-\t\r\n-\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n-\t\t{\r\n-\t\t\tvar dist = distance(data.target, data.start);\r\n-\t\t\tvar id = shannon(dist, data.target.w);\r\n-\r\n-\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n-\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n-\r\n-\t\t\tscatterGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n-\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n-\t\t\t\t.attr('cx', scatterX(id))\r\n-\t\t\t\t.attr('cy', scatterY(dt))\r\n-\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(200)\r\n-\t\t\t\t\t\t.ease('bounce')\r\n-\t\t\t\t\t\t.attr('r', 3);\t\t\r\n-\t\t\r\n-\t\t\tvar A = data.start;\r\n-\t\t\tvar B = data.target;\r\n-\t\t\tvar path = data.path;\r\n-\t\t\r\n-\t\t\tvar hit = {}\r\n-\t\t\tvar q = project(A, B, data.hit);\r\n-\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n-\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n-\t\t\r\n-\t\t\r\n-\t\t\tplotHitsGroup.append('circle')\r\n-\t\t\t\t.attr('class', 'hit')\r\n-\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n-\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n-\t\t\t\t.attr('r', 6)\r\n-\t\t\t\t.style('fill', 'red')\r\n-\t\t\t\t.style('opacity', 1)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.ease('linear')\r\n-\t\t\t\t\t\t.attr('r', 3);\r\n-\t\t\r\n-\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n-\t\t\tfor (var i = 0; i < path.length; i++) {\r\n-\t\t\t\tvar p = path[i];\r\n-\t\t\t\r\n-\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\telse\r\n-\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\tplotPositionGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n-\t\t\t\t\t.attr('x2', scaleX(x))\r\n-\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n-\t\t\t\t\t.attr('y2', scaleY(y))\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n-\t\t\t\t\t.attr('class', 'live')\r\n-\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n-\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n-\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n-\t\t\t\t\t.attr('y2', scaleV(speed))\r\n-\r\n-\t\t\t\t\t.style('stroke', v(speed))\r\n-\t\t\t\t\t.transition()\r\n-\t\t\t\t\t\t.duration(LIVE_STAY)\r\n-\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar last = {}\r\n-\t\t\t\tlast.x = x;\r\n-\t\t\t\tlast.y = y;\r\n-\t\t\t\tlast.t = p.t;\r\n-\t\t\t\tlast.v = speed;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\trandomizeParams: function() {\r\n-\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n-\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n-\r\n-\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n-\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n-\r\n-\t\tthis.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n-\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n-\t},\r\n-\t\r\n-\taddDataSet: function() {\r\n-\t\t\r\n-\t\t// first update the plots\r\n-\t\tthis.updatePlots(this);\r\n-\t\t\r\n-\t\tthis.dataCnt++;\r\n-\t\tvar num = this.dataCnt;\r\n-\t\tvar colour = this.colour(randomAB(0, 10));\r\n-\t\t\r\n-\t\tthis.data[num] = {data: [], colour: colour};\r\n-\t\t\r\n-\t\tthis.currentDataSet = num\r\n-\t\tvar div = d3.select('#dataSets').append('div')\r\n-\t\t\t.attr('id', 'dataSet' + num)\r\n-\t\t\t.text('Data Set ' + num + ' ')\r\n-\t\t\t.style('background-color', colour);\r\n-\t\t\r\n-\t\tvar buttonID ='removeDataSet' + num;\r\n-\t\tdiv.append('button')\r\n-\t\t\t.attr('id', buttonID)\r\n-\t\t\t.attr('type', 'button')\r\n-\t\t\t.text('delete!');\r\n-\t\t\t\r\n-\t\tvar that = this;\r\n-\t\t\r\n-\t\t$('#' + buttonID).click(function() {\r\n-\t\t\tthat.deleteDataSet(num);\r\n-\t\t\tfittsTest.active = false;\r\n-\t\t});\r\n-\t\t\r\n-\t\t$('#dataSet' + num).click(function() {\r\n-\t\t\tif (assIsKey(num, that.data)) {\r\n-\t\t\t\tthat.currentDataSet = num;\r\n-\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\tfittsTest.active = false;\r\n-\r\n-\t\t})\r\n-\t\t\t\r\n-\t\tthis.highlightDataSet(num);\r\n-\t\t// add colour\r\n-\t\t\r\n-\t},\r\n-\t\r\n-\tdeleteDataSet: function(num) {\r\n-\t\tif (assSize(this.data) == 1)\r\n-\t\t{\r\n-\t\t\talert('Cannot delete data set! Create another data set first.')\r\n-\t\t} else\r\n-\t\t{\t\r\n-\t\t\td3.select('#dataSet' + num).remove();\r\n-\t\t\tdelete this.data[num];\r\n-\t\t\t\r\n-\t\t\tscatterGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('r', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.attr('width', 0)\r\n-\t\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\t\r\n-\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n-\t\t\t\t.transition()\r\n-\t\t\t\t\t.duration(500)\r\n-\t\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t\t.remove()\r\n-\t\t\t\r\n-\t\t\tif (num == this.currentDataSet) {\r\n-\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n-\t\t\t\tthis.currentDataSet = first;\r\n-\t\t\t\tthis.highlightDataSet(first);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tthis.updatePlots(this);\r\n-\t\t}\r\n-\t},\r\n-\t\r\n-\thighlightDataSet: function(num) {\r\n-\t\td3.selectAll('#dataSets div')\r\n-\t\t\t.attr('class', '');\r\n-\t\td3.select('#dataSet' + num)\r\n-\t\t\t.attr('class', 'active')\r\n-\t},\r\n-\t\r\n-\tupdatePlots: function(that) {\r\n-\t\t// a little I candy :D\r\n-\t\td3.select('body').append('div')\r\n-\t\t\t.attr('class', 'msg')\r\n-\t\t\t.text('updating plots...')\r\n-\t\t\t.style('opacity', 1)\r\n-\t\t\t.transition()\r\n-\t\t\t\t.duration(2000)\r\n-\t\t\t\t\t.style('opacity', 0)\r\n-\t\t\t\t\t.remove();\r\n-\t\t\t\t\t\r\n-\t\t/* we haven't moven inside the test area, so we can as well disable\r\n-\t\t * the test for now\r\n-\t\t */\r\n-\t\tthat.active = false;\r\n-\r\n-\t\t// for each data set\r\n-\t\t// compute We and IDe and Throughput for each category\r\n-\r\n-\t\t// process data\r\n-\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n-\t\tfor (var key in that.data) { // for each data set\r\n-\t\t\t\r\n-\t\t\tdataSetIndex++;\r\n-\t\t\t\r\n-\t\t\tvar groups = [];\r\n-\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n-\t\t\t\tvar datum = that.data[key].data[i];\r\n-\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n-\t\t\t\tif (!groups[groupID]) {\r\n-\t\t\t\t\tgroups[groupID] = [];\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n-\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n-\t\t\t\t\r\n-\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n-\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n-\t\t\t\tdatum.projectedHitOffsetY = y;\r\n-\t\t\t\t\r\n-\t\t\t\tgroups[groupID].push(datum);\r\n-\t\t\t}\r\n-\r\n-\t\t\tvar newData = [];\r\n-\t\t\tfor (var group in groups) {\r\n-\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n-\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n-\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n-\t\t\t\t\r\n-\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n-\t\t\t\t\tvar datum = groups[group][i];\r\n-\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n-\t\t\t\t\tvar De = dEffective;\r\n-\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n-\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n-\t\t\t\t\tnewData.push(datum);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\r\n-\t\t\t// insert stuff in SVG\r\n-\t\t\tvar colour = that.data[key].colour;\r\n-\t\t\t\r\n-\t\t\tvar insert = function(d) {\r\n-\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n-\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n-\t\t\t\t.attr('r', 5);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n-\t\t\t\t.data(newData);\r\n-\t\t\t\r\n-\t\t\tcircles.enter()\r\n-\t\t\t\t.append('circle')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t\t.style('opacity', 0.5)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\r\n-\t\t\tcircles.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t\t.call(insert);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t// ==================== regression ========================\r\n-\t\t\tvar covTIDe = cov(newData,\r\n-\t\t\t\tfunction(d) { return d.time; },\r\n-\t\t\t\tfunction(d) { return d.IDe});\r\n-\t\t\t\r\n-\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n-\t\t\t\r\n-\t\t\tif (varIDe > 0)\r\n-\t\t\t\tvar b = covTIDe / varIDe;\r\n-\t\t\telse\r\n-\t\t\t\tvar b = 0;\r\n-\t\t\t\r\n-\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n-\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n-\t\t\tvar a = mT - b * mIDe;\r\n-\t\t\t\r\n-\t\t\tif (!isNaN(a))\r\n-\t\t\t{\t\t\t\r\n-\t\t\t\tvar makeLine = function(d) {\r\n-\t\t\t\t\treturn d\r\n-\t\t\t\t\t\t.attr('x1', 0)\r\n-\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n-\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n-\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n-\t\t\t\t}\r\n-\t\t\t\r\n-\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n-\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n-\t\t\t\r\n-\t\t\t\tregression.enter().append('line')\r\n-\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t.style('stroke-width', 2)\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t\r\n-\t\t\t\tregression.transition()\r\n-\t\t\t\t\t.call(makeLine);\r\n-\t\t\t}\r\n-\t\t\t\t\r\n-\r\n-\t\t\t// ============== histogram ====================\r\n-\t\t\tvar histThroughput = d3.layout.histogram()\r\n-\t\t\t\t.bins(20)\r\n-\t\t\t\t.range([0,10])\r\n-\t\t\t\t.value(function(d){return d.throughput;})\r\n-\t\t\t\t\r\n-\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n-\t\t\t\r\n-\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n-\t\t\t\t\t\t\r\n-\t\t\tvar histX = d3.scale.ordinal()\r\n-\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n-\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n-\t\r\n-\t\t\tvar histY = d3.scale.linear()\r\n-\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n-\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n-\t\t\t\t\r\n-\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n-\t\t\t\t.data(throughputHistogramData);\r\n-\t\t\t\t\r\n-\t\t\t\r\n-\t\t\tvar numDataSets = assSize(that.data);\r\n-\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n-\t\t\t\r\n-\t\t\tvar makeRect = function(d) {\r\n-\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n-\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n-\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n-\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tvar histXAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histX)\r\n-\t\t\t\t.ticks(2);\r\n-\r\n-\t\t\tvar histYAxis = d3.svg.axis()\r\n-\t\t\t\t.scale(histY)\r\n-\t\t\t\t.ticks(5)\r\n-\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n-\t\t\t\r\n-\t\t\tthroughputGroup.append(\"g\")\r\n-\t\t\t\t.attr(\"class\", \"axis\")\r\n-\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n-\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n-\t\r\n-\t\t\t// throughputGroup.append(\"g\")\r\n-\t\t\t\t// .attr(\"class\", \"axis\")\r\n-\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n-\t\t\t\r\n-\t\t\tthroughputRect.enter()\r\n-\t\t\t\t.append('rect')\r\n-\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t.attr('rx', 2)\r\n-\t\t\t\t.attr('ry', 2)\r\n-\t\t\t\t.style('fill', colour)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\tthroughputRect.transition()\r\n-\t\t\t\t.duration(500)\r\n-\t\t\t\t.call(makeRect)\r\n-\t\t\t\t\r\n-\t\t\t// ==================== eff position and speed ===================\r\n-\t\t\t// more or less copy-pasted from above\r\n-\t\t\tfor (var i = 0; i < newData.length; i++)\r\n-\t\t\t{\r\n-\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n-\t\t\t\tvar A = newData[i].start;\r\n-\t\t\t\tvar B = newData[i].target\r\n-\t\t\t\tvar dAB = distance(A, B);\r\n-\t\t\t\tvar offset = newData[i].distance - dAB;\r\n-\t\t\t\toffset = 0;\r\n-\t\t\t\t\t\t\t\t\r\n-\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n-\t\t\t\t{\r\n-\r\n-\t\t\t\t\tvar p = newData[i].path[j];\r\n-\t\t\t\r\n-\t\t\t\t\tvar q = project(A, B, p);\r\n-\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n-\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n-\r\n-\t\t\t\t\tvar dt = p.t - last.t;\r\n-\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n-\t\t\t\t\tif (dt > 0)\r\n-\t\t\t\t\t\tvar speed = dist / dt;\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tvar speed = 0;\r\n-\t\t\r\n-\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n-\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n-\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n-\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\r\n-\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n-\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n-\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n-\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n-\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n-\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n-\t\t\t\t\t\t.style('stroke', colour)\r\n-\t\t\t\t\t\t.style('opacity', 0.5);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tvar last = {}\r\n-\t\t\t\t\tlast.x = x;\r\n-\t\t\t\t\tlast.y = y;\r\n-\t\t\t\t\tlast.t = p.t;\r\n-\t\t\t\t\tlast.v = speed;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\t\t\r\n-\t}\r\n-};\r\n-\r\n-// _empirical_ covariance\r\n-function cov(data, extractorA, extractorB) {\r\n-\t\r\n-\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tvar mA = mean(data, extractorA);\r\n-\tvar mB = mean(data, extractorB);\r\n-\t\r\n-\tvar cov = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n-\t}\r\n-\t\r\n-\treturn cov / (data.length - 1);\r\n-}\r\n-\r\n-function variance(data, extractor) {\r\n-\treturn cov(data, extractor, extractor);\r\n-}\r\n-\r\n-function mean(data, extractor) {\r\n-\tvar sum = 0;\r\n-\tfor (var i = 0; i < data.length; i++) {\r\n-\t\tsum += extractor(data[i]);\r\n-\t}\r\n-\treturn sum / data.length;\r\n-}\r\n-\r\n-function randomAB(a, b) {\r\n-\treturn a + Math.random() * (b - a);\r\n-}\r\n-\r\n-function assSize(assArr) {\r\n-\tvar size = 0;\r\n-\tfor (var _ in assArr) {\r\n-\t\tsize++;\r\n-\t}\r\n-\treturn size;\r\n-}\r\n-\r\n-function assFirstKey(assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\treturn key;\r\n-\t\tbreak;\r\n-\t}\r\n-}\r\n-\r\n-function assIsKey(needle, assArr) {\r\n-\tfor (var key in assArr) {\r\n-\t\tif (needle == key) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t}\r\n-\treturn false;\r\n-}\r\n-\r\n-\r\n-/**\r\n- * Project a point q onto the line p0-p1\r\n- * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n- */\r\n-function project(A, B, p) {\r\n-\tvar AB = minus(B, A);\r\n-\tvar AB_squared = dot(AB, AB);\r\n-\tif (AB_squared == 0) {\r\n-\t\treturn A;\r\n-\t}\r\n-\telse {\r\n-\t\tvar Ap = minus(p, A);\r\n-\t\tvar t = dot(Ap, AB) / AB_squared;\r\n-\t\treturn {x: A.x + t * AB.x,\r\n-\t\t\t\ty: A.y + t * AB.y,\r\n-\t\t\t\tt: t};\r\n-\t}\r\n-}\r\n-\r\n-\r\n-\r\n-function mouseMoved()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseMoved(m[0], m[1])\r\n-}\r\n-\r\n-function mouseClicked()\r\n-{\r\n-\tvar m = d3.svg.mouse(this);\r\n-\tfittsTest.mouseClicked(m[0], m[1]);\r\n-}\r\n-\r\n-function dot(a, b) {\r\n-\treturn (a.x * b.x) + (a.y * b.y);\r\n-}\r\n-\r\n-// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\n-function isLeft(A, B, p){\r\n-     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n-}\r\n-\r\n-function minus(a, b) {\r\n-\treturn {x: a.x - b.x, y: a.y - b.y};\r\n-}\r\n-\r\n-function distance(a, b) {\r\n-\tvar dx = a.x - b.x;\r\n-\tvar dy = a.y - b.y;\r\n-\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n-}\r\n-\r\n-function sign(a) {\r\n-\treturn a >=0 ? 1 : -1;\r\n-}\r\n-\r\n-function rgb2Hex(r, g, b) {\r\n-\treturn '#' +\r\n-\t\tclampInt(0, 255, r).toString(16) +\r\n-\t\tclampInt(0, 255, g).toString(16) +\r\n-\t\tclampInt(0, 255, b).toString(16);\r\n-}\r\n-\r\n-function clampInt(lower, upper, x) {\r\n-\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n-}\r\n-\r\n-function shannon(A, W) {\r\n-\treturn Math.log(A / W + 1) / Math.log(2);\r\n-}\r\n-\r\n-function bgRect(d, dim) {\r\n-\treturn d.append('rect')\r\n-\t\t.attr('cx', 0)\r\n-\t\t.attr('cy', 0)\r\n-\t\t.attr('width', dim.width)\r\n-\t\t.attr('height', dim.height)\r\n-\t\t.attr('class', 'back');\r\n-}\r\n-\r\n-\r\n-\r\n-var testAreaSVG = d3.select('#test-area').append('svg')\r\n-\t.attr('width', testDimension.width)\r\n-\t.attr('height', testDimension.height)\r\n-\t.style('pointer-events', 'all')\r\n-    .on('mousemove', mouseMoved)\r\n-\t.on('mousedown', mouseClicked)\r\n-\t.call(bgRect, testDimension);\r\n-\r\n-var plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n-\t.attr('width', plotPositionDimension.width)\r\n-\t.attr('height', plotPositionDimension.height)\r\n-\t.call(bgRect, plotPositionDimension)\r\n-\r\n-var plotPositionGroup = plotPositionSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n-\r\n-var positionXAxis = d3.svg.axis()\r\n-\t.scale(scaleX)\r\n-\t.ticks(7)\r\n-var positionYAxis = d3.svg.axis()\r\n-\t.scale(scaleY)\r\n-\t.ticks(6)\r\n-\t\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\n-plotPositionGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\r\n-\t\r\n-\r\n-\r\n-var plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n-\t.attr('width', plotHitsDimension.width)\r\n-\t.attr('height', plotHitsDimension.height)\r\n-\t.call(bgRect, plotHitsDimension);\r\n-\r\n-\r\n-var plotHitsGroup = plotHitsSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\n-plotHitsGroup.append('circle')\r\n-\t.attr('cx', 0)\r\n-\t.attr('cy', 0)\r\n-\t.attr('r', plotHitsDimension.innerWidth/2)\r\n-\t.style('opacity', 0.1)\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -plotHitsDimension.cx)\r\n-\t.attr('y2', 0);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', -10);\r\n-plotHitsGroup.append('line')\r\n-\t.attr('x1', 0)\r\n-\t.attr('y1', 0)\r\n-\t.attr('x2', -10)\r\n-\t.attr('y2', 10);\r\n-\r\n-\t\r\n-\t\r\n-var plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n-\t.attr('width', plotVelocitiesDimension.width)\r\n-\t.attr('height', plotVelocitiesDimension.height)\r\n-\t.call(bgRect, plotVelocitiesDimension);\r\n-\r\n-var plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n-\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n-\r\n-var speedXAxis = d3.svg.axis()\r\n-\t.scale(scaleT)\r\n-\t.ticks(7)\r\n-var speedYAxis = d3.svg.axis()\r\n-\t.scale(scaleV)\r\n-\t.ticks(6)\r\n-\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n-\t// .append('text')\r\n-\t// \t.text('time in ms')\r\n-\t// \t.attr('x', 80)\r\n-\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n-\t// \t.style('text-anchor', 'middle');\r\n-\t\t\r\n-plotVelocitiesGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('pixel/ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 80)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-\r\n-var scatterSVG = d3.select('#plot-scatter').append('svg')\r\n-\t.attr('width', plotScatterDimension.width)\r\n-\t.attr('height', plotScatterDimension.height)\r\n-\t.call(bgRect, plotScatterDimension);\r\n-\r\n-var scatterGroup = scatterSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var xAxis = d3.svg.axis()\r\n-\t.scale(scatterX)\r\n-\t.ticks(7)\r\n-\t.tickSize(6, 3, 0);\r\n-var yAxis = d3.svg.axis()\r\n-\t.scale(scatterY)\r\n-\t.ticks(6)\r\n-\t.tickSize(6, 3, 6)\r\n-\t\r\n-// print axes\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('ID')\r\n-\t\t// \t.attr('x', 80)\r\n-\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-scatterGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n-\t\t// .append('text')\r\n-\t\t// \t.text('time in ms')\r\n-\t\t// \t.attr('x', -20)\r\n-\t\t// \t.attr('y', 65)\r\n-\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n-\t\t// \t.style('text-anchor', 'middle');\r\n-\r\n-\r\n-\r\n-var scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n-\t.attr('width', scatterEffectiveDimension.width)\r\n-\t.attr('height', scatterEffectiveDimension.height)\r\n-\t.call(bgRect, scatterEffectiveDimension);\r\n-\r\n-var scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n-\r\n-// define Axes.\r\n-var effXAxis = d3.svg.axis()\r\n-\t.scale(effScatterX)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 0);\r\n-\r\n-var effYAxis = d3.svg.axis()\r\n-\t.scale(effScatterY)\r\n-\t.ticks(10)\r\n-\t.tickSize(6, 3, 6)\r\n-\r\n-\r\n-// print axes\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n-\r\n-scatterEffectiveGroup.append(\"g\")\r\n-    .attr(\"class\", \"axis\")\r\n-\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n-    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n-\r\n-var throughputSVG = d3.select('#throughput').append('svg')\r\n-\t.attr('width', histDimension.width)\r\n-\t.attr('height', histDimension.height)\r\n-\t.call(bgRect, histDimension);\r\n-\r\n-var throughputGroup = throughputSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n-\r\n-//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n-\r\n-\t\r\n-\r\n-var positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n-\t.attr('width', positionEffectiveDimension.width)\r\n-\t.attr('height', positionEffectiveDimension.height)\r\n-\t.call(bgRect, positionEffectiveDimension);\r\n-\r\n-var positionTargetsGroup = positionEffectiveSVG.append('g')\r\n-\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n-\r\n-var positionEffXAxis = d3.svg.axis()\r\n-\t.scale(effPositionX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n-\r\n-var positionEffYAxis = d3.svg.axis()\r\n-\t.scale(effPositionY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n-\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n-\t.call(positionEffXAxis.orient('bottom'));\r\n-\t\r\n-positionEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t\t.call(positionEffYAxis.orient('left'));\t\r\n-\t\r\n-\t\r\n-\t\r\n-\r\n-var speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n-\t.attr('width', speedEffectiveDimension.width)\r\n-\t.attr('height', speedEffectiveDimension.height)\r\n-\t.call(bgRect, speedEffectiveDimension);\r\n-\r\n-var speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n-\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n-\r\n-var speedEffXAxis = d3.svg.axis()\r\n-\t.scale(effSpeedX)\r\n-\t.ticks(10)\r\n-\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n-\r\n-var speedEffYAxis = d3.svg.axis()\r\n-\t.scale(effSpeedY)\r\n-\t.ticks(5)\r\n-\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n-\t.call(speedEffXAxis.orient('bottom'));\r\n-\r\n-speedEffectiveGroup.append('g')\r\n-\t.attr('class', 'axis')\r\n-\t.call(speedEffYAxis.orient('left'));\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-// init code\r\n-// should probably go somewhere else though. \r\n-fittsTest.active = false;\r\n-fittsTest.generateISOPositions(15, 150, 10);\r\n-fittsTest.updateISOCircles();\r\n-d3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\n-d3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\n-fittsTest.addDataSet();\r\n-\r\n-// setup sliders\r\n-$(\"#sliderDistance\").slider({\r\n-\tmin: fittsTest.isoLimits.minD,\r\n-\tmax: fittsTest.isoLimits.maxD,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.distance,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.distance = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$(\"#sliderWidth\").slider({\r\n-\tmin: fittsTest.isoLimits.minW,\r\n-\tmax: fittsTest.isoLimits.maxW,\r\n-\tstep: 1,\r\n-\tvalue: fittsTest.isoParams.width,\r\n-\tslide: function(event, ui) {\r\n-\t\tfittsTest.isoParams.width = ui.value;\r\n-\t\tfittsTest.updateISOCircles();\r\n-\t\td3.select('#sliderWidthValue').text(ui.value);\r\n-\t\t$('#randomizeCheckbox').attr('checked', false);\r\n-\t\tfittsTest.isoParams.randomize = false;\r\n-\t}\r\n-});\r\n-\r\n-$('#randomizeButton').click(function() {\r\n-\tfittsTest.randomizeParams();\r\n-\t$('#randomizeCheckbox').attr('checked', true);\r\n-\tfittsTest.isoParams.randomize = true;\r\n-});\r\n-\r\n-$('#randomizeCheckbox').change(function(event) {\r\n-\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n-})\r\n-\r\n-\r\n-// const fs = require('fs').promises;\r\n-// const path = require('path');\r\n-// const process = require('process');\r\n-// const {authenticate} = require('@google-cloud/local-auth');\r\n-// const {google} = require('googleapis');\r\n-// const sheets = google.sheets('v4'); \r\n-\r\n-// const SCOPES = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/spreadsheets'];\r\n-// const TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\n-// const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n-\r\n-\r\n-\r\n-\r\n-// async function authorize() {\r\n-// \tconst content = await fs.readFile(TOKEN_PATH);\r\n-// \tconst credentials = JSON.parse(content);\r\n-// \tlet client = google.auth.fromJSON(credentials);\r\n-// \tclient = await authenticate({\r\n-// \t\tscopes: SCOPES,\r\n-// \t\tkeyfilePath: CREDENTIALS_PATH,\r\n-// \t});\r\n-// \treturn client;\r\n-// }\r\n-\r\n-\r\n-\r\n-// async function primary(){\r\n-// \tconst authClient = await authorize();\r\n-//    \tconst request = {\r\n-// \tspreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n-// \trange: 'A1',  \r\n-// \tvalueInputOption: 'RAW',  \r\n-// \tinsertDataOption: 'OVERWRITE', \r\n-// \trequestBody: fittsTest.data,\r\n-// \tauth: authClient,\r\n-// \t};\r\n-\r\n-//     const response = (await sheets.spreadsheets.values.append(request)).data;\r\n-//     console.log(JSON.stringify(response, null, 2));\r\n-// }\r\n-\r\n-$('#addDataSetButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-});\r\n-\r\n-$('#downloadDataButton').click(function() {\r\n-\tfittsTest.addDataSet();\r\n-\tfittsTest.active = false;\r\n-\tconsole.log(fittsTest.data[fittsTest.dataCnt - 1].data)\r\n-\r\n-\t\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686113705723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1222,9 +1222,9 @@\n \r\n $('#downloadDataButton').click(function() {\r\n \tlet newData = [];\r\n \r\n-\tfor (var i = 1; i <= fittsTest.data.length - 1; i++) {\r\n+\tfor (var i = 1; i <= fittsTest.data.length - 2; i++) {\r\n \t\tnewData[i - 1] = fittsTest.data[i];\r\n \t}\r\n \t// while (i <= fittsTest.dataCnt - 1) {\r\n     // \tlet j = 0;\r\n"
                }
            ],
            "date": 1686102649326,
            "name": "Commit-0",
            "content": "\"use strict\";\r\n\r\n/**\r\n * Create dimensions from the given values and store them for later use.\r\n * All values should be positive and make sense.\r\n * @param {number} width The outer width of the area.\r\n * @param {number} height The outer height of the area.\r\n * @param {number} top Margin form the top edge.\r\n * @param {number} right Margin form the right edge.\r\n * @param {number} bottom Margin form the bottom edge.\r\n * @param {number} left Margin form the left edge.\r\n */\r\nfunction makeDimension(width, height, top, right, bottom, left) {\r\n\treturn {width: width,\r\n\t\theight: height,\r\n\t\tinnerWidth: width - (left + right),\r\n\t\tinnerHeight: height - (top + bottom),\r\n\t\ttop: top,\r\n\t\tright: right,\r\n\t\tbottom: bottom,\r\n\t\tleft: left,\r\n\t\tcx: (width - (left + right)) / 2 + left,\r\n\t\tcy: (height - (top + bottom)) / 2 + top};\r\n}\r\n\r\n// set up dimensions for the plotting.\r\nvar testDimension = makeDimension(620, 400, 30, 30, 30, 30);\r\nvar plotPositionDimension = makeDimension(220, 200, 30, 30, 30, 30);\r\nvar plotVelocitiesDimension = plotPositionDimension;\r\nvar plotHitsDimension = plotPositionDimension;\r\nvar plotScatterDimension = makeDimension(220, 200, 30, 30, 30, 50);\r\nvar scatterEffectiveDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\nvar positionEffectiveDimension = makeDimension(540, 200, 30, 30, 30, 40);\r\nvar speedEffectiveDimension = positionEffectiveDimension;\r\nvar histDimension = makeDimension(540, 300, 30, 30, 30, 50);\r\n\r\nvar LIVE_STAY = 1000;\r\nvar MAX_TIME = 2000;\r\nvar UPDATE_DELAY = MAX_TIME;\r\nvar MAX_SPEED = 6; // pixel/ms\r\n\r\nfunction rHit(r, rTarget) {\r\n\treturn ((plotHitsDimension.innerWidth / 2) / rTarget) * r;\r\n};\r\n\r\n\r\n\r\nfunction v(v) {\r\n\tvar colour = 'rgb(' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ', 0, 0)';\r\n\treturn colour;\r\n};\r\n\r\nvar scatterX = d3.scale.linear()\r\n\t.domain([0.5, 5.5])\r\n\t.range([0, plotScatterDimension.innerWidth]);\r\n\r\nvar scatterY = d3.scale.linear()\r\n\t.domain([MAX_TIME, 0])\r\n\t.range([0, plotScatterDimension.innerHeight]);\r\n\r\nvar scaleT = d3.scale.linear()\r\n\t.domain([0, 1000])\r\n\t.range([0, plotVelocitiesDimension.innerWidth]);\r\n\r\nvar scaleV = d3.scale.linear()\r\n\t.domain([0, MAX_SPEED])\r\n\t.range([plotVelocitiesDimension.innerHeight, 0]);\r\n\r\nvar scaleX = d3.scale.linear()\r\n\t.domain([-20, 300])\r\n\t.range([0, plotPositionDimension.innerWidth]);\r\n\r\nvar scaleY = d3.scale.linear()\r\n\t.domain([-50, 50])\r\n\t.range([plotPositionDimension.innerHeight, 0]);\r\n\r\nvar effScatterX = d3.scale.linear()\r\n\t.domain([0.5, 6.5])\r\n\t.range([0, scatterEffectiveDimension.innerWidth]);\r\n\r\nvar effScatterY = d3.scale.linear()\r\n\t.domain([MAX_TIME, 0])\r\n\t.range([0, scatterEffectiveDimension.innerHeight]);\r\n\r\nvar effPositionX = d3.scale.linear()\r\n\t.domain([-60, 400])\r\n\t.range([0, positionEffectiveDimension.innerWidth]);\r\n\r\nvar effPositionY = d3.scale.linear()\r\n\t.domain([-50, 50])\r\n\t.range([positionEffectiveDimension.innerHeight, 0]);\r\n\t\r\nvar effSpeedX = d3.scale.linear()\r\n\t.domain([0, MAX_TIME])\r\n\t.range([0, speedEffectiveDimension.innerWidth])\r\n\r\nvar effSpeedY = d3.scale.linear()\r\n\t.domain([0, MAX_SPEED])\r\n\t.range([speedEffectiveDimension.innerHeight, 0]);\r\n\r\n\r\n\r\nvar fittsTest = {\r\n\ttarget: {x: 0, y: 0, r: 10},\r\n\tstart: {x: 0, y: 0, t: 0},\r\n\tlast: {},\r\n\r\n\tisoPositions: [],\r\n\tcurrentPosition: 0,\r\n\tcurrentCount: 0,\r\n\tmiss: 0,\r\n\tisoLimits: {minD: 120, maxD: 300, minW:10 , maxW: 100},\r\n\tisoParams: {num: 9, distance: 200, width: 50, randomize: true},\r\n\t\r\n\tcurrentPath: [],\r\n\tactive: false,\r\n\t\r\n\tdata: [],\r\n\tcurrentDataSet: 0,\r\n\tdataCnt: 0,\r\n\t\r\n\tcolour: d3.scale.category10(),\r\n\t\r\n\tsumID: 0,\r\n\tsumTime: 0,\r\n\t\r\n\tupdateTimeoutHandle: undefined,\r\n\t\r\n\tgenerateTarget: function() {\r\n\t\tthis.target = this.isoPositions[this.currentPosition];\r\n\t\tthis.target.distance = this.isoParams.distance;\r\n\t\tthis.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length/2)) % this.isoPositions.length;\r\n\t\t\r\n\t\tvar target = testAreaSVG.selectAll('#target').data([this.target]);\r\n\t\t\r\n\t\tvar insert = function(d) {\r\n\t\t\td.attr('cx', function(d) { return d.x; })\r\n\t\t\t.attr('cy', function(d) { return d.y; })\r\n\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n\t\t}\r\n\r\n\t\ttarget.enter()\r\n\t\t\t.append('circle')\r\n\t\t\t\t.attr('id', 'target')\r\n\t\t\t\t.style('fill', 'red')\r\n\t\t\t\t.call(insert);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\ttarget.transition()\r\n\t\t\t\t.call(insert);\r\n\r\n\t\t\r\n\t\tthis.active = true;\r\n\t},\r\n\t\r\n\tupdateISOCircles: function() {\r\n\t\tthis.currentCount = 0;\r\n\t\t\r\n\t\tthis.generateISOPositions(this.isoParams.num,\r\n\t\t\tthis.isoParams.distance,\r\n\t\t\tthis.isoParams.width);\r\n\r\n\t\tvar circles = testAreaSVG.selectAll('circle').data(this.isoPositions);\r\n\t\t\r\n\t\tvar insert = function(d) {\r\n\t\t\td.attr('cx', function(d) { return d.x; })\r\n\t\t\t.attr('cy', function(d) { return d.y; })\r\n\t\t\t.attr('r', function(d) { return d.w / 2; });\r\n\t\t}\r\n\r\n\t\tcircles.enter()\r\n\t\t\t.append('circle')\r\n\t\t\t\t.attr('class', 'iso')\r\n\t\t\t\t.call(insert);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\tcircles.transition()\r\n\t\t\t.call(insert);\r\n\t\t\r\n\t\tcircles.exit()\r\n\t\t\t.transition()\r\n\t\t\t\t.attr('r', 0)\r\n\t\t\t\t.remove();\r\n\t\t\t\t\r\n\t\tthis.currentPosition = 0;\r\n\t\tthis.generateTarget();\r\n\t\tthis.active = false;\r\n},\r\n\t\r\n\tgenerateISOPositions: function(num, d, w) {\r\n\t\t\r\n\t\t// remove all data from live view\r\n\t\tplotHitsGroup.selectAll('circle.hit')\r\n\t\t\t.transition()\r\n\t\t\t\t.duration(LIVE_STAY)\r\n\t\t\t\t\t.ease('linear')\r\n\t\t\t\t\t.attr('r', 2)\r\n\t\t\t\t\t.style('opacity', 0)\r\n\t\t\t\t\t.remove();\r\n\t\t\r\n\t\tplotPositionGroup.selectAll('line.live')\r\n\t\t\t.transition()\r\n\t\t\t\t.duration(LIVE_STAY)\r\n\t\t\t\t.style('stroke-opacity', 0)\r\n\t\t\t\t.remove();\r\n\r\n\t\tplotVelocitiesGroup.selectAll('line.live')\r\n\t\t\t.transition()\r\n\t\t\t\t.duration(LIVE_STAY)\r\n\t\t\t\t.style('stroke-opacity', 0)\r\n\t\t\t\t.remove();\r\n\t\t\r\n\t\t\r\n\t\tthis.isoPositions = [];\r\n\t\t\r\n\t\tfor (var i = 0; i < num; i++) {\r\n\t\t\tthis.isoPositions[i] = {x: testDimension.cx + ((d/2) * Math.cos((2 * Math.PI * i) / num)),\r\n\t\t\t\ty: testDimension.cy + ((d/2) * Math.sin((2 * Math.PI * i) / num)),\r\n\t\t\t\tw: w};\r\n\t\t}\r\n\t},\r\n\t\r\n\tremoveTarget: function() {\r\n\t\ttestAreaSVG.selectAll('#target').data([])\r\n\t\t\t.exit()\r\n\t\t\t\t.remove();\r\n\t\t\t\t\r\n\t\tthis.active = false;\r\n\t\tthis.currentPath = [];\r\n\t},\r\n\t\r\n\tmouseClicked: function(x, y) {\r\n\t\t\r\n\t\tif (distance({x: x, y: y}, this.target) < (this.target.w / 2)) {\r\n\t\t\tthis.addDataPoint({start: this.start,\r\n\t\t\t\t\t\t\t   target: this.target,\r\n\t\t\t\t\t\t\t   path: this.currentPath,\r\n\t\t\t\t\t\t\t   hit: {x: x, y: y, t: (new Date).getTime()}});\r\n\t\t\tthis.removeTarget();\r\n\r\n\t\t\tif (this.isoParams.randomize && this.currentCount >= this.isoPositions.length) {\r\n\t\t\t\tthis.randomizeParams();\r\n\t\t\t\tthis.currentCount = 0;\r\n\t\t\t\tthis.currentPosition = 0;\r\n\t\t\t\tthis.miss = 0;\r\n\t\t\t\tthis.updateISOCircles;\r\n\t\t\t\tthis.generateTarget();\r\n\t\t\t\tthis.active = false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.currentCount++;\r\n\t\t\t\tthis.generateTarget();\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\tthis.last = {x: x, y: y, t: (new Date).getTime()};\r\n\t\t\tthis.start = this.last;\r\n\t\t\tthis.currentPath.push(this.last);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.miss++;\r\n\t\t}\r\n\t},\r\n\t\r\n\tmouseMoved: function(x, y) {\r\n\t\tif (this.active) {\r\n\t\t\t// skip if the mouse did actually not move\r\n\t\t\t// that should practically never happen...\r\n\t\t\tif (x == this.last.x && y == this.last.y) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// set timeout for updating plots\r\n\t\t\tif (this.updateTimeoutHandle) {\r\n\t\t\t\twindow.clearTimeout(this.updateTimeoutHandle);\r\n\t\t\t}\r\n\t\t\tthis.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tvar newPoint = {x: x, y: y, t: (new Date).getTime()}\r\n\t\t\tthis.currentPath.push(newPoint)\r\n\t\t\t\r\n\t\t\tvar dt = newPoint.t - this.last.t;\r\n\t\t\tvar dist = distance(this.last, {x: x, y: y})\r\n\t\t\tif (dt > 0)\r\n\t\t\t\tvar speed = dist / dt;\r\n\t\t\telse\r\n\t\t\t\tvar speed = 0;\r\n\t\t\t\r\n\t\t\ttestAreaSVG.append('line')\r\n\t\t\t\t// .attr('class', '')\r\n\t\t\t\t.attr('x1', this.last.x)\r\n\t\t\t\t.attr('x2', newPoint.x)\r\n\t\t\t\t.attr('y1', this.last.y)\r\n\t\t\t\t.attr('y2', newPoint.y)\r\n\t\t\t\t.style('stroke', v(speed))\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(5000)\r\n\t\t\t\t\t.style('stroke-opacity', 0)\r\n\t\t\t\t\t.remove();\r\n\t\t\t\t\r\n\t\t\tthis.last = newPoint;\r\n\t\t}\r\n\t},\r\n\t\r\n\taddDataPoint: function(data) {\r\n\t\t// add point to data array for plotting into ID/time scatter plot\r\n\t\tif (this.active == false)\r\n\t\t\treturn;\r\n\r\n\t\tvar dt = data.hit.t - data.start.t;\r\n\t\r\n\t\tif (dt < MAX_TIME)  // skip if obvious outlier\r\n\t\t{\r\n\t\t\tvar dist = distance(data.target, data.start);\r\n\t\t\tvar id = shannon(dist, data.target.w);\r\n\r\n\t\t\tthis.data[this.currentDataSet].data.push({time: dt, distance: data.target.distance, width: data.target.w, hit: data.hit,\r\n\t\t\t\tstart: data.start, target: data.target, path: data.path});\r\n\r\n\t\t\tscatterGroup.append('circle')\r\n\t\t\t\t.attr('class', 'cat' + this.currentDataSet)\r\n\t\t\t\t.style('fill', this.data[this.currentDataSet].colour)\r\n\t\t\t\t.attr('cx', scatterX(id))\r\n\t\t\t\t.attr('cy', scatterY(dt))\r\n\t\t\t\t.attr('r', 0)\r\n\t\t\t\t\t.transition()\r\n\t\t\t\t\t\t.duration(200)\r\n\t\t\t\t\t\t.ease('bounce')\r\n\t\t\t\t\t\t.attr('r', 3);\t\t\r\n\t\t\r\n\t\t\tvar A = data.start;\r\n\t\t\tvar B = data.target;\r\n\t\t\tvar path = data.path;\r\n\t\t\r\n\t\t\tvar hit = {}\r\n\t\t\tvar q = project(A, B, data.hit);\r\n\t\t\thit.x = distance(q, B) * sign(q.t - 1);\r\n\t\t\thit.y = distance(q, data.hit) * isLeft(A, B, data.hit);\r\n\t\t\r\n\t\t\r\n\t\t\tplotHitsGroup.append('circle')\r\n\t\t\t\t.attr('class', 'hit')\r\n\t\t\t\t.attr('cx', rHit(hit.x, data.target.w / 2))\r\n\t\t\t\t.attr('cy', rHit(hit.y, data.target.w / 2))\r\n\t\t\t\t.attr('r', 6)\r\n\t\t\t\t.style('fill', 'red')\r\n\t\t\t\t.style('opacity', 1)\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(500)\r\n\t\t\t\t\t\t.ease('linear')\r\n\t\t\t\t\t\t.attr('r', 3);\r\n\t\t\r\n\t\t\tvar last = { x: 0, y: 0, t: data.start.t, v: 0};\r\n\t\t\tfor (var i = 0; i < path.length; i++) {\r\n\t\t\t\tvar p = path[i];\r\n\t\t\t\r\n\t\t\t\tvar q = project(A, B, p);\r\n\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n\r\n\t\t\t\tvar dt = p.t - last.t;\r\n\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n\t\t\t\tif (dt > 0)\r\n\t\t\t\t\tvar speed = dist / dt;\r\n\t\t\t\telse\r\n\t\t\t\t\tvar speed = 0;\r\n\t\t\r\n\t\t\t\tplotPositionGroup.append('svg:line')\r\n\t\t\t\t\t.attr('class', 'live')\r\n\t\t\t\t\t.attr('x1', scaleX(last.x))\r\n\t\t\t\t\t.attr('x2', scaleX(x))\r\n\t\t\t\t\t.attr('y1', scaleY(last.y))\r\n\t\t\t\t\t.attr('y2', scaleY(y))\r\n\t\t\t\t\t.style('stroke', v(speed))\r\n\t\t\t\t\t.transition()\r\n\t\t\t\t\t\t.duration(LIVE_STAY)\r\n\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n\t\t\t\r\n\t\t\t\tplotVelocitiesGroup.append('svg:line')\r\n\t\t\t\t\t.attr('class', 'live')\r\n\t\t\t\t\t.attr('x1', scaleT(last.t - data.start.t))\r\n\t\t\t\t\t.attr('x2', scaleT(p.t - data.start.t))\r\n\t\t\t\t\t.attr('y1', scaleV(last.v))\r\n\t\t\t\t\t.attr('y2', scaleV(speed))\r\n\r\n\t\t\t\t\t.style('stroke', v(speed))\r\n\t\t\t\t\t.transition()\r\n\t\t\t\t\t\t.duration(LIVE_STAY)\r\n\t\t\t\t\t\t.style('stroke-opacity', 0.5);\r\n\t\t\t\t\t\r\n\t\t\t\tvar last = {}\r\n\t\t\t\tlast.x = x;\r\n\t\t\t\tlast.y = y;\r\n\t\t\t\tlast.t = p.t;\r\n\t\t\t\tlast.v = speed;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n\trandomizeParams: function() {\r\n\t\tthis.isoParams.distance = Math.floor(randomAB(this.isoLimits.minD, this.isoLimits.maxD));\r\n\t\tthis.isoParams.width = Math.floor(randomAB(this.isoLimits.minW, this.isoLimits.maxW));\r\n\r\n\t\t$('#sliderDistance').slider('value', this.isoParams.distance);\r\n\t\t$('#sliderWidth').slider('value', this.isoParams.width);\r\n\r\n\t\tthis.updateISOCircles();\r\n\t\td3.select('#sliderDistanceValue').text(this.isoParams.distance);\r\n\t\td3.select('#sliderWidthValue').text(this.isoParams.width);\r\n\t},\r\n\t\r\n\taddDataSet: function() {\r\n\t\t\r\n\t\t// first update the plots\r\n\t\tthis.updatePlots(this);\r\n\t\t\r\n\t\tthis.dataCnt++;\r\n\t\tvar num = this.dataCnt;\r\n\t\tvar colour = this.colour(randomAB(0, 10));\r\n\t\t\r\n\t\tthis.data[num] = {data: [], colour: colour};\r\n\t\t\r\n\t\tthis.currentDataSet = num\r\n\t\tvar div = d3.select('#dataSets').append('div')\r\n\t\t\t.attr('id', 'dataSet' + num)\r\n\t\t\t.text('Data Set ' + num + ' ')\r\n\t\t\t.style('background-color', colour);\r\n\t\t\r\n\t\tvar buttonID ='removeDataSet' + num;\r\n\t\tdiv.append('button')\r\n\t\t\t.attr('id', buttonID)\r\n\t\t\t.attr('type', 'button')\r\n\t\t\t.text('delete!');\r\n\t\t\t\r\n\t\tvar that = this;\r\n\t\t\r\n\t\t$('#' + buttonID).click(function() {\r\n\t\t\tthat.deleteDataSet(num);\r\n\t\t\tfittsTest.active = false;\r\n\t\t});\r\n\t\t\r\n\t\t$('#dataSet' + num).click(function() {\r\n\t\t\tif (assIsKey(num, that.data)) {\r\n\t\t\t\tthat.currentDataSet = num;\r\n\t\t\t\tthat.highlightDataSet(num);\t\t\t\t\r\n\t\t\t}\r\n\t\t\tfittsTest.active = false;\r\n\r\n\t\t})\r\n\t\t\t\r\n\t\tthis.highlightDataSet(num);\r\n\t\t// add colour\r\n\t\t\r\n\t},\r\n\t\r\n\tdeleteDataSet: function(num) {\r\n\t\tif (assSize(this.data) == 1)\r\n\t\t{\r\n\t\t\talert('Cannot delete data set! Create another data set first.')\r\n\t\t} else\r\n\t\t{\t\r\n\t\t\td3.select('#dataSet' + num).remove();\r\n\t\t\tdelete this.data[num];\r\n\t\t\t\r\n\t\t\tscatterGroup.selectAll('.cat' + num)\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(500)\r\n\t\t\t\t\t\t.attr('r', 0)\r\n\t\t\t\t\t\t.remove();\r\n\t\t\t\r\n\t\t\tscatterEffectiveGroup.selectAll('.cat' + num)\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(500)\r\n\t\t\t\t\t\t.style('opacity', 0)\r\n\t\t\t\t\t\t.remove();\r\n\t\t\t\r\n\t\t\tthroughputGroup.selectAll('rect.cat' + num)\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(500)\r\n\t\t\t\t\t\t.attr('width', 0)\r\n\t\t\t\t\t\t.remove();\r\n\t\t\t\t\t\t\r\n\t\t\tpositionEffectiveGroup.selectAll('line.cat' + num)\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(500)\r\n\t\t\t\t\t\t.style('opacity', 0)\r\n\t\t\t\t\t\t.remove()\r\n\t\t\t\r\n\t\t\tspeedEffectiveGroup.selectAll('line.cat' + num)\r\n\t\t\t\t.transition()\r\n\t\t\t\t\t.duration(500)\r\n\t\t\t\t\t\t.style('opacity', 0)\r\n\t\t\t\t\t\t.remove()\r\n\t\t\t\r\n\t\t\tif (num == this.currentDataSet) {\r\n\t\t\t\tvar first = parseInt(assFirstKey(this.data));\r\n\t\t\t\tthis.currentDataSet = first;\r\n\t\t\t\tthis.highlightDataSet(first);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.updatePlots(this);\r\n\t\t}\r\n\t},\r\n\t\r\n\thighlightDataSet: function(num) {\r\n\t\td3.selectAll('#dataSets div')\r\n\t\t\t.attr('class', '');\r\n\t\td3.select('#dataSet' + num)\r\n\t\t\t.attr('class', 'active')\r\n\t},\r\n\t\r\n\tupdatePlots: function(that) {\r\n\t\t// a little I candy :D\r\n\t\td3.select('body').append('div')\r\n\t\t\t.attr('class', 'msg')\r\n\t\t\t.text('updating plots...')\r\n\t\t\t.style('opacity', 1)\r\n\t\t\t.transition()\r\n\t\t\t\t.duration(2000)\r\n\t\t\t\t\t.style('opacity', 0)\r\n\t\t\t\t\t.remove();\r\n\t\t\t\t\t\r\n\t\t/* we haven't moven inside the test area, so we can as well disable\r\n\t\t * the test for now\r\n\t\t */\r\n\t\tthat.active = false;\r\n\r\n\t\t// for each data set\r\n\t\t// compute We and IDe and Throughput for each category\r\n\r\n\t\t// process data\r\n\t\tvar dataSetIndex = -1; // evil hack to make it start at 0 then.\r\n\t\tfor (var key in that.data) { // for each data set\r\n\t\t\t\r\n\t\t\tdataSetIndex++;\r\n\t\t\t\r\n\t\t\tvar groups = [];\r\n\t\t\tfor (var i = 0; i < that.data[key].data.length; i++) { // for each datum\r\n\t\t\t\tvar datum = that.data[key].data[i];\r\n\t\t\t\tvar groupID = datum.distance.toString() + datum.width.toString();\r\n\t\t\t\tif (!groups[groupID]) {\r\n\t\t\t\t\tgroups[groupID] = [];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar q = project(datum.start, datum.target, datum.hit);\r\n\t\t\t\t// var x = distance(q, datum.start) * sign(q.t);\r\n\t\t\t\tvar y = distance(q, datum.hit) * isLeft(datum.start, datum.target, datum.hit);\r\n\t\t\t\t\r\n\t\t\t\tdatum.realDistance = distance(datum.start, datum.hit); // use real distance here.\r\n\t\t\t\tdatum.projectedHitOffsetX = distance(q, datum.target) * sign(q.t - 1);\r\n\t\t\t\tdatum.projectedHitOffsetY = y;\r\n\t\t\t\t\r\n\t\t\t\tgroups[groupID].push(datum);\r\n\t\t\t}\r\n\r\n\t\t\tvar newData = [];\r\n\t\t\tfor (var group in groups) {\r\n\t\t\t\tif (groups[group].length < 3) { // exlcude groups with length < 3\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\tvar xEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetX; }))\r\n\t\t\t\tvar yEffective = 4.133 * Math.sqrt(variance(groups[group], function(d) { return d.projectedHitOffsetY; }))\r\n\t\t\t\tvar dEffective = mean(groups[group], function(d) { return d.realDistance; });\r\n\t\t\t\t\r\n\t\t\t\tfor (var i = 0; i < groups[group].length; i++) {\r\n\t\t\t\t\tvar datum = groups[group][i];\r\n\t\t\t\t\tvar We = Math.min(xEffective, yEffective); // SMALLER-OF model (MacKenzie, Buxton 92)\r\n\t\t\t\t\tvar De = dEffective;\r\n\t\t\t\t\tdatum.IDe = shannon(De, We);\r\n\t\t\t\t\tdatum.throughput = 1000 * (datum.IDe/datum.time);\r\n\t\t\t\t\tnewData.push(datum);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// insert stuff in SVG\r\n\t\t\tvar colour = that.data[key].colour;\r\n\t\t\t\r\n\t\t\tvar insert = function(d) {\r\n\t\t\t\td.attr('cx', function(d) { return effScatterX(d.IDe); })\r\n\t\t\t\t.attr('cy', function(d) { return effScatterY(d.time); })\r\n\t\t\t\t.attr('r', 5);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar circles = scatterEffectiveGroup.selectAll('circle.cat' + key)\r\n\t\t\t\t.data(newData);\r\n\t\t\t\r\n\t\t\tcircles.enter()\r\n\t\t\t\t.append('circle')\r\n\t\t\t\t\t.attr('class', 'cat' + key)\r\n\t\t\t\t\t.style('fill', colour)\r\n\t\t\t\t\t.style('opacity', 0.5)\r\n\t\t\t\t\t.call(insert);\r\n\t\t\t\r\n\t\t\tcircles.transition()\r\n\t\t\t\t.duration(500)\r\n\t\t\t\t\t.call(insert);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t// ==================== regression ========================\r\n\t\t\tvar covTIDe = cov(newData,\r\n\t\t\t\tfunction(d) { return d.time; },\r\n\t\t\t\tfunction(d) { return d.IDe});\r\n\t\t\t\r\n\t\t\tvar varIDe = variance(newData, function(d) { return d.IDe; })\r\n\t\t\t\r\n\t\t\tif (varIDe > 0)\r\n\t\t\t\tvar b = covTIDe / varIDe;\r\n\t\t\telse\r\n\t\t\t\tvar b = 0;\r\n\t\t\t\r\n\t\t\tvar mT = mean(newData, function(d) { return d.time; });\r\n\t\t\tvar mIDe = mean(newData, function(d) { return d.IDe; });\r\n\t\t\tvar a = mT - b * mIDe;\r\n\t\t\t\r\n\t\t\tif (!isNaN(a))\r\n\t\t\t{\t\t\t\r\n\t\t\t\tvar makeLine = function(d) {\r\n\t\t\t\t\treturn d\r\n\t\t\t\t\t\t.attr('x1', 0)\r\n\t\t\t\t\t\t.attr('x2', scatterEffectiveDimension.innerWidth)\r\n\t\t\t\t\t\t.attr('y1', function(d) { return effScatterY(d.y1); })\r\n\t\t\t\t\t\t.attr('y2', function(d) { return effScatterY(d.y2); })\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\tvar regression = scatterEffectiveGroup.selectAll('line.cat' + key)\r\n\t\t\t\t\t.data([{y1:a + b * 0.5, y2: a + b * 6.5}]);\r\n\t\t\t\r\n\t\t\t\tregression.enter().append('line')\r\n\t\t\t\t\t.attr('class', 'cat' + key)\r\n\t\t\t\t\t.style('stroke', colour)\r\n\t\t\t\t\t.style('stroke-width', 2)\r\n\t\t\t\t\t.call(makeLine);\r\n\t\t\t\r\n\t\t\t\tregression.transition()\r\n\t\t\t\t\t.call(makeLine);\r\n\t\t\t}\r\n\t\t\t\t\r\n\r\n\t\t\t// ============== histogram ====================\r\n\t\t\tvar histThroughput = d3.layout.histogram()\r\n\t\t\t\t.bins(20)\r\n\t\t\t\t.range([0,10])\r\n\t\t\t\t.value(function(d){return d.throughput;})\r\n\t\t\t\t\r\n\t\t\tvar throughputHistogramData = histThroughput(newData)\r\n\t\t\t\r\n\t//\t\thistYMax = d3.max(throughputHistogramData, function(d) { return d.y; });\r\n\t\t\t\t\t\t\r\n\t\t\tvar histX = d3.scale.ordinal()\r\n\t\t\t\t.domain(throughputHistogramData.map(function(d) { return d.x; }))\t\r\n\t\t\t\t.rangeRoundBands([0, histDimension.innerWidth]);\r\n\t\r\n\t\t\tvar histY = d3.scale.linear()\r\n\t\t\t\t.domain([0, d3.max(throughputHistogramData, function(d) { return d.y; })])\r\n\t\t\t\t.range([histDimension.innerHeight, 0]);\r\n\t\t\t\t\r\n\t\t\tvar throughputRect = throughputGroup.selectAll('rect.cat' + key)\r\n\t\t\t\t.data(throughputHistogramData);\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\tvar numDataSets = assSize(that.data);\r\n\t\t\tvar xOffset = (histX.rangeBand() / numDataSets) * dataSetIndex;\r\n\t\t\t\r\n\t\t\tvar makeRect = function(d) {\r\n\t\t\t\td.attr('x', function(offset) { return function(d) { return (histX(d.x) + offset); }; }(xOffset))\r\n\t\t\t\t.attr('y', function(scale) { return function(d) { return (scale(d.y)); }; }(histY))\r\n\t\t\t\t.attr('width', (histX.rangeBand() / numDataSets) - 1)\r\n\t\t\t\t.attr('height', function(scale) { return function(d) { return (scale(0) - scale(d.y)); }; }(histY));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar histXAxis = d3.svg.axis()\r\n\t\t\t\t.scale(histX)\r\n\t\t\t\t.ticks(2);\r\n\r\n\t\t\tvar histYAxis = d3.svg.axis()\r\n\t\t\t\t.scale(histY)\r\n\t\t\t\t.ticks(5)\r\n\t\t\tthroughputGroup.selectAll(\"g.axis\").remove()\t\r\n\t\t\t\r\n\t\t\tthroughputGroup.append(\"g\")\r\n\t\t\t\t.attr(\"class\", \"axis\")\r\n\t\t\t\t.attr(\"transform\", \"translate(0,\" + histDimension.innerHeight + \")\")\r\n\t\t\t\t.call(histXAxis.tickSize(6,3,6).orient(\"bottom\"));\t\r\n\t\r\n\t\t\t// throughputGroup.append(\"g\")\r\n\t\t\t\t// .attr(\"class\", \"axis\")\r\n\t\t\t\t// .call(histYAxis.tickSize(-histDimension.innerWidth).orient(\"left\"));\r\n\t\t\t\r\n\t\t\tthroughputRect.enter()\r\n\t\t\t\t.append('rect')\r\n\t\t\t\t.attr('class', 'cat' + key)\r\n\t\t\t\t.attr('rx', 2)\r\n\t\t\t\t.attr('ry', 2)\r\n\t\t\t\t.style('fill', colour)\r\n\t\t\t\t.call(makeRect)\r\n\t\t\t\t\r\n\t\t\tthroughputRect.transition()\r\n\t\t\t\t.duration(500)\r\n\t\t\t\t.call(makeRect)\r\n\t\t\t\t\r\n\t\t\t// ==================== eff position and speed ===================\r\n\t\t\t// more or less copy-pasted from above\r\n\t\t\tfor (var i = 0; i < newData.length; i++)\r\n\t\t\t{\r\n\t\t\t\tvar last = { x: 0, y: 0, t: newData[i].start.t, v: 0};\r\n\t\t\t\tvar A = newData[i].start;\r\n\t\t\t\tvar B = newData[i].target\r\n\t\t\t\tvar dAB = distance(A, B);\r\n\t\t\t\tvar offset = newData[i].distance - dAB;\r\n\t\t\t\toffset = 0;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\tfor (var j = 0; j < newData[i].path.length; j++)\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tvar p = newData[i].path[j];\r\n\t\t\t\r\n\t\t\t\t\tvar q = project(A, B, p);\r\n\t\t\t\t\tvar x = distance(q, A) * sign(q.t);\r\n\t\t\t\t\tvar y = distance(q, p) * isLeft(A, B, p);\r\n\r\n\t\t\t\t\tvar dt = p.t - last.t;\r\n\t\t\t\t\tvar dist = distance(last, {x: x, y: y});\r\n\t\t\t\t\tif (dt > 0)\r\n\t\t\t\t\t\tvar speed = dist / dt;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvar speed = 0;\r\n\t\t\r\n\t\t\t\t\tpositionEffectiveGroup.append('line')\r\n\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n\t\t\t\t\t\t.attr('x1', effPositionX(last.x + offset))\r\n\t\t\t\t\t\t.attr('x2', effPositionX(x + offset))\r\n\t\t\t\t\t\t.attr('y1', effPositionY(last.y))\r\n\t\t\t\t\t\t.attr('y2', effPositionY(y))\r\n\t\t\t\t\t\t.style('stroke', colour)\r\n\t\t\t\t\t\t.style('opacity', 0.5);\r\n\t\t\t\r\n\t\t\t\t\tspeedEffectiveGroup.append('line')\r\n\t\t\t\t\t\t.attr('class', 'cat' + key)\r\n\t\t\t\t\t\t.attr('x1', effSpeedX(last.t - A.t))\r\n\t\t\t\t\t\t.attr('x2', effSpeedX(p.t - A.t))\r\n\t\t\t\t\t\t.attr('y1', effSpeedY(last.v))\r\n\t\t\t\t\t\t.attr('y2', effSpeedY(speed))\r\n\t\t\t\t\t\t.style('stroke', colour)\r\n\t\t\t\t\t\t.style('opacity', 0.5);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar last = {}\r\n\t\t\t\t\tlast.x = x;\r\n\t\t\t\t\tlast.y = y;\r\n\t\t\t\t\tlast.t = p.t;\r\n\t\t\t\t\tlast.v = speed;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n};\r\n\r\n// _empirical_ covariance\r\nfunction cov(data, extractorA, extractorB) {\r\n\t\r\n\tif (data.length <= 1) { // no covariance for 0 or 1 element.\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tvar mA = mean(data, extractorA);\r\n\tvar mB = mean(data, extractorB);\r\n\t\r\n\tvar cov = 0;\r\n\tfor (var i = 0; i < data.length; i++) {\r\n\t\tcov += (extractorA(data[i]) - mA) * (extractorB(data[i]) - mB);\r\n\t}\r\n\t\r\n\treturn cov / (data.length - 1);\r\n}\r\n\r\nfunction variance(data, extractor) {\r\n\treturn cov(data, extractor, extractor);\r\n}\r\n\r\nfunction mean(data, extractor) {\r\n\tvar sum = 0;\r\n\tfor (var i = 0; i < data.length; i++) {\r\n\t\tsum += extractor(data[i]);\r\n\t}\r\n\treturn sum / data.length;\r\n}\r\n\r\nfunction randomAB(a, b) {\r\n\treturn a + Math.random() * (b - a);\r\n}\r\n\r\nfunction assSize(assArr) {\r\n\tvar size = 0;\r\n\tfor (var _ in assArr) {\r\n\t\tsize++;\r\n\t}\r\n\treturn size;\r\n}\r\n\r\nfunction assFirstKey(assArr) {\r\n\tfor (var key in assArr) {\r\n\t\treturn key;\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nfunction assIsKey(needle, assArr) {\r\n\tfor (var key in assArr) {\r\n\t\tif (needle == key) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n/**\r\n * Project a point q onto the line p0-p1\r\n * Code taken from: http://www.alecjacobson.com/weblog/?p=1486\r\n */\r\nfunction project(A, B, p) {\r\n\tvar AB = minus(B, A);\r\n\tvar AB_squared = dot(AB, AB);\r\n\tif (AB_squared == 0) {\r\n\t\treturn A;\r\n\t}\r\n\telse {\r\n\t\tvar Ap = minus(p, A);\r\n\t\tvar t = dot(Ap, AB) / AB_squared;\r\n\t\treturn {x: A.x + t * AB.x,\r\n\t\t\t\ty: A.y + t * AB.y,\r\n\t\t\t\tt: t};\r\n\t}\r\n}\r\n\r\n\r\n\r\nfunction mouseMoved()\r\n{\r\n\tvar m = d3.svg.mouse(this);\r\n\tfittsTest.mouseMoved(m[0], m[1])\r\n}\r\n\r\nfunction mouseClicked()\r\n{\r\n\tvar m = d3.svg.mouse(this);\r\n\tfittsTest.mouseClicked(m[0], m[1]);\r\n}\r\n\r\nfunction dot(a, b) {\r\n\treturn (a.x * b.x) + (a.y * b.y);\r\n}\r\n\r\n// coutesy of http://stackoverflow.com/questions/3461453/determine-which-side-of-a-line-a-point-lies\r\nfunction isLeft(A, B, p){\r\n     return ((B.x - A.x)*(p.y - A.y) - (B.y - A.y)*(p.x - A.x)) >= 0 ? 1: -1;\r\n}\r\n\r\nfunction minus(a, b) {\r\n\treturn {x: a.x - b.x, y: a.y - b.y};\r\n}\r\n\r\nfunction distance(a, b) {\r\n\tvar dx = a.x - b.x;\r\n\tvar dy = a.y - b.y;\r\n\treturn Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n}\r\n\r\nfunction sign(a) {\r\n\treturn a >=0 ? 1 : -1;\r\n}\r\n\r\nfunction rgb2Hex(r, g, b) {\r\n\treturn '#' +\r\n\t\tclampInt(0, 255, r).toString(16) +\r\n\t\tclampInt(0, 255, g).toString(16) +\r\n\t\tclampInt(0, 255, b).toString(16);\r\n}\r\n\r\nfunction clampInt(lower, upper, x) {\r\n\treturn Math.min(upper, Math.max(lower, Math.floor(x)));\r\n}\r\n\r\nfunction shannon(A, W) {\r\n\treturn Math.log(A / W + 1) / Math.log(2);\r\n}\r\n\r\nfunction bgRect(d, dim) {\r\n\treturn d.append('rect')\r\n\t\t.attr('cx', 0)\r\n\t\t.attr('cy', 0)\r\n\t\t.attr('width', dim.width)\r\n\t\t.attr('height', dim.height)\r\n\t\t.attr('class', 'back');\r\n}\r\n\r\n\r\n\r\nvar testAreaSVG = d3.select('#test-area').append('svg')\r\n\t.attr('width', testDimension.width)\r\n\t.attr('height', testDimension.height)\r\n\t.style('pointer-events', 'all')\r\n    .on('mousemove', mouseMoved)\r\n\t.on('mousedown', mouseClicked)\r\n\t.call(bgRect, testDimension);\r\n\r\nvar plotPositionSVG = d3.select('#plot-positions').append('svg')\r\n\t.attr('width', plotPositionDimension.width)\r\n\t.attr('height', plotPositionDimension.height)\r\n\t.call(bgRect, plotPositionDimension)\r\n\r\nvar plotPositionGroup = plotPositionSVG.append('g')\r\n\t.attr('transform', 'translate('+ plotPositionDimension.left + ', ' + plotPositionDimension.top + ')');\r\n\r\nvar positionXAxis = d3.svg.axis()\r\n\t.scale(scaleX)\r\n\t.ticks(7)\r\nvar positionYAxis = d3.svg.axis()\r\n\t.scale(scaleY)\r\n\t.ticks(6)\r\n\t\r\nplotPositionGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n    .call(positionXAxis.tickSize(plotPositionDimension.innerHeight).orient(\"bottom\"));\r\nplotPositionGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n    .call(positionYAxis.tickSize(-plotPositionDimension.innerWidth).orient(\"left\"));\r\n\r\n\r\n\t\r\n\r\n\r\nvar plotHitsSVG = d3.select('#plot-hits').append('svg')\r\n\t.attr('width', plotHitsDimension.width)\r\n\t.attr('height', plotHitsDimension.height)\r\n\t.call(bgRect, plotHitsDimension);\r\n\r\n\r\nvar plotHitsGroup = plotHitsSVG.append('g')\r\n\t\t.attr('transform', 'translate('+ plotHitsDimension.cx + ', ' + plotHitsDimension.cy + ')');\r\nplotHitsGroup.append('circle')\r\n\t.attr('cx', 0)\r\n\t.attr('cy', 0)\r\n\t.attr('r', plotHitsDimension.innerWidth/2)\r\n\t.style('opacity', 0.1)\r\nplotHitsGroup.append('line')\r\n\t.attr('x1', 0)\r\n\t.attr('y1', 0)\r\n\t.attr('x2', -plotHitsDimension.cx)\r\n\t.attr('y2', 0);\r\nplotHitsGroup.append('line')\r\n\t.attr('x1', 0)\r\n\t.attr('y1', 0)\r\n\t.attr('x2', -10)\r\n\t.attr('y2', -10);\r\nplotHitsGroup.append('line')\r\n\t.attr('x1', 0)\r\n\t.attr('y1', 0)\r\n\t.attr('x2', -10)\r\n\t.attr('y2', 10);\r\n\r\n\t\r\n\t\r\nvar plotVelocitiesSVG = d3.select('#plot-velocities').append('svg')\r\n\t.attr('width', plotVelocitiesDimension.width)\r\n\t.attr('height', plotVelocitiesDimension.height)\r\n\t.call(bgRect, plotVelocitiesDimension);\r\n\r\nvar plotVelocitiesGroup = plotVelocitiesSVG.append('g')\r\n\t.attr('transform', 'translate('+ plotVelocitiesDimension.left + ', ' + plotVelocitiesDimension.top + ')');\r\n\r\nvar speedXAxis = d3.svg.axis()\r\n\t.scale(scaleT)\r\n\t.ticks(7)\r\nvar speedYAxis = d3.svg.axis()\r\n\t.scale(scaleV)\r\n\t.ticks(6)\r\n\r\nplotVelocitiesGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n    .call(speedXAxis.tickSize(plotVelocitiesDimension.innerHeight).orient(\"bottom\"))\r\n\t// .append('text')\r\n\t// \t.text('time in ms')\r\n\t// \t.attr('x', 80)\r\n\t// \t.attr('y', plotVelocitiesDimension.innerHeight + 25)\r\n\t// \t.style('text-anchor', 'middle');\r\n\t\t\r\nplotVelocitiesGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n    .call(speedYAxis.tickSize(-plotVelocitiesDimension.innerWidth).orient(\"left\"))\r\n\t\t// .append('text')\r\n\t\t// \t.text('pixel/ms')\r\n\t\t// \t.attr('x', -20)\r\n\t\t// \t.attr('y', 80)\r\n\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n\t\t// \t.style('text-anchor', 'middle');\r\n\r\n\r\n\r\n\r\nvar scatterSVG = d3.select('#plot-scatter').append('svg')\r\n\t.attr('width', plotScatterDimension.width)\r\n\t.attr('height', plotScatterDimension.height)\r\n\t.call(bgRect, plotScatterDimension);\r\n\r\nvar scatterGroup = scatterSVG.append('g')\r\n\t.attr('transform', 'translate('+ (plotScatterDimension.left) + ',' + plotScatterDimension.top + ' )');\r\n\r\n// define Axes.\r\nvar xAxis = d3.svg.axis()\r\n\t.scale(scatterX)\r\n\t.ticks(7)\r\n\t.tickSize(6, 3, 0);\r\nvar yAxis = d3.svg.axis()\r\n\t.scale(scatterY)\r\n\t.ticks(6)\r\n\t.tickSize(6, 3, 6)\r\n\t\r\n// print axes\r\nscatterGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n    .call(xAxis.tickSize(plotScatterDimension.innerHeight).orient(\"bottom\"))\r\n\t\t// .append('text')\r\n\t\t// \t.text('ID')\r\n\t\t// \t.attr('x', 80)\r\n\t\t// \t.attr('y', plotScatterDimension.innerHeight + 25)\r\n\t\t// \t.style('text-anchor', 'middle');\r\nscatterGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n    .call(yAxis.tickSize(-plotScatterDimension.innerWidth).orient(\"left\"))\r\n\t\t// .append('text')\r\n\t\t// \t.text('time in ms')\r\n\t\t// \t.attr('x', -20)\r\n\t\t// \t.attr('y', 65)\r\n\t\t// \t.attr('transform', 'rotate(-90, -20, 80)')\r\n\t\t// \t.style('text-anchor', 'middle');\r\n\r\n\r\n\r\nvar scatterEffectiveSVG = d3.select('#scatterEffective').append('svg')\r\n\t.attr('width', scatterEffectiveDimension.width)\r\n\t.attr('height', scatterEffectiveDimension.height)\r\n\t.call(bgRect, scatterEffectiveDimension);\r\n\r\nvar scatterEffectiveGroup = scatterEffectiveSVG.append('g')\r\n\t.attr('transform', 'translate('+ (scatterEffectiveDimension.left) + ',' + scatterEffectiveDimension.top + ' )');\r\n\r\n// define Axes.\r\nvar effXAxis = d3.svg.axis()\r\n\t.scale(effScatterX)\r\n\t.ticks(10)\r\n\t.tickSize(6, 3, 0);\r\n\r\nvar effYAxis = d3.svg.axis()\r\n\t.scale(effScatterY)\r\n\t.ticks(10)\r\n\t.tickSize(6, 3, 6)\r\n\r\n\r\n// print axes\r\nscatterEffectiveGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n    .call(effXAxis.tickSize(scatterEffectiveDimension.innerHeight).orient(\"bottom\"));\r\n\r\nscatterEffectiveGroup.append(\"g\")\r\n    .attr(\"class\", \"axis\")\r\n\t// .attr(\"transform\", \"translate( 0, \" + plotScatterDimension.height + \")\")\r\n    .call(effYAxis.tickSize(-scatterEffectiveDimension.innerWidth).orient(\"left\"));\r\n\r\nvar throughputSVG = d3.select('#throughput').append('svg')\r\n\t.attr('width', histDimension.width)\r\n\t.attr('height', histDimension.height)\r\n\t.call(bgRect, histDimension);\r\n\r\nvar throughputGroup = throughputSVG.append('g')\r\n\t.attr('transform', 'translate('+ (histDimension.left) + ',' + histDimension.top + ' )')\r\n\r\n//\t.call(histYAxis.tickSize(histDimension.innerWidth).orient(\"left\"));\r\n\r\n\t\r\n\r\nvar positionEffectiveSVG = d3.select('#positionEffective').append('svg')\r\n\t.attr('width', positionEffectiveDimension.width)\r\n\t.attr('height', positionEffectiveDimension.height)\r\n\t.call(bgRect, positionEffectiveDimension);\r\n\r\nvar positionTargetsGroup = positionEffectiveSVG.append('g')\r\n\t\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n\r\nvar positionEffectiveGroup = positionEffectiveSVG.append('g')\r\n\t.attr('transform', 'translate('+ (positionEffectiveDimension.left) + ',' + positionEffectiveDimension.top + ' )');\r\n\r\nvar positionEffXAxis = d3.svg.axis()\r\n\t.scale(effPositionX)\r\n\t.ticks(10)\r\n\t.tickSize(-positionEffectiveDimension.innerHeight)\r\n\r\nvar positionEffYAxis = d3.svg.axis()\r\n\t.scale(effPositionY)\r\n\t.ticks(5)\r\n\t.tickSize(-positionEffectiveDimension.innerWidth)\r\n\r\npositionEffectiveGroup.append('g')\r\n\t.attr('class', 'axis')\r\n\t.attr('transform', 'translate(0, ' + positionEffectiveDimension.innerHeight + ')')\r\n\t.call(positionEffXAxis.orient('bottom'));\r\n\t\r\npositionEffectiveGroup.append('g')\r\n\t.attr('class', 'axis')\r\n\t\t.call(positionEffYAxis.orient('left'));\t\r\n\t\r\n\t\r\n\t\r\n\r\nvar speedEffectiveSVG = d3.select('#speedEffective').append('svg')\r\n\t.attr('width', speedEffectiveDimension.width)\r\n\t.attr('height', speedEffectiveDimension.height)\r\n\t.call(bgRect, speedEffectiveDimension);\r\n\r\nvar speedEffectiveGroup = speedEffectiveSVG.append('g')\r\n\t.attr('transform', 'translate('+ (speedEffectiveDimension.left) + ',' + speedEffectiveDimension.top + ' )');\r\n\r\nvar speedEffXAxis = d3.svg.axis()\r\n\t.scale(effSpeedX)\r\n\t.ticks(10)\r\n\t.tickSize(-speedEffectiveDimension.innerHeight)\r\n\r\nvar speedEffYAxis = d3.svg.axis()\r\n\t.scale(effSpeedY)\r\n\t.ticks(5)\r\n\t.tickSize(-speedEffectiveDimension.innerWidth)\r\n\r\nspeedEffectiveGroup.append('g')\r\n\t.attr('class', 'axis')\r\n\t.attr('transform', 'translate(0, ' + speedEffectiveDimension.innerHeight + ')')\r\n\t.call(speedEffXAxis.orient('bottom'));\r\n\r\nspeedEffectiveGroup.append('g')\r\n\t.attr('class', 'axis')\r\n\t.call(speedEffYAxis.orient('left'));\r\n\r\n\r\n\r\n\r\n\r\n// init code\r\n// should probably go somewhere else though. \r\nfittsTest.active = false;\r\nfittsTest.generateISOPositions(15, 150, 10);\r\nfittsTest.updateISOCircles();\r\nd3.select('#sliderDistanceValue').text(fittsTest.isoParams.distance);\r\nd3.select('#sliderWidthValue').text(fittsTest.isoParams.width);\r\nfittsTest.addDataSet();\r\n\r\n// setup sliders\r\n$(\"#sliderDistance\").slider({\r\n\tmin: fittsTest.isoLimits.minD,\r\n\tmax: fittsTest.isoLimits.maxD,\r\n\tstep: 1,\r\n\tvalue: fittsTest.isoParams.distance,\r\n\tslide: function(event, ui) {\r\n\t\tfittsTest.isoParams.distance = ui.value;\r\n\t\tfittsTest.updateISOCircles();\r\n\t\td3.select('#sliderDistanceValue').text(ui.value);\r\n\t\t$('#randomizeCheckbox').attr('checked', false);\r\n\t\tfittsTest.isoParams.randomize = false;\r\n\t}\r\n});\r\n\r\n$(\"#sliderWidth\").slider({\r\n\tmin: fittsTest.isoLimits.minW,\r\n\tmax: fittsTest.isoLimits.maxW,\r\n\tstep: 1,\r\n\tvalue: fittsTest.isoParams.width,\r\n\tslide: function(event, ui) {\r\n\t\tfittsTest.isoParams.width = ui.value;\r\n\t\tfittsTest.updateISOCircles();\r\n\t\td3.select('#sliderWidthValue').text(ui.value);\r\n\t\t$('#randomizeCheckbox').attr('checked', false);\r\n\t\tfittsTest.isoParams.randomize = false;\r\n\t}\r\n});\r\n\r\n$('#randomizeButton').click(function() {\r\n\tfittsTest.randomizeParams();\r\n\t$('#randomizeCheckbox').attr('checked', true);\r\n\tfittsTest.isoParams.randomize = true;\r\n});\r\n\r\n$('#randomizeCheckbox').change(function(event) {\r\n\tfittsTest.isoParams.randomize = $(this).attr('checked');\r\n})\r\n\r\nconst {google} = require('googleapis');\r\nconst sheets = google.sheets('v4');\r\n\r\nasync function primary(){\r\n\tconst authClient = await authorize();\r\n   const request = {\r\n  spreadsheetId: '1bBq3rj-n9Uu6sb7_R3qj0ehQfr1oRF_yZNBY856sO74', \r\n  range: 'A1:AZ',  \r\n  valueInputOption: 'RAW',  \r\n  insertDataOption: 'OVERWRITE', \r\n  resource: {values: fittsTest.data},\r\n  auth: authClient,\r\n  };\r\n}\r\n\r\n$('#addDataSetButton').click(function() {\r\n\tfittsTest.addDataSet();\r\n\tfittsTest.active = false;\r\n\t\r\n\tprimary();\r\n\r\n\t\r\n\t\r\n});\r\n\r\n\r\n\r\n  \r\n    const response = (await sheets.spreadsheets.values.append(request)).data;\r\n    // TODO: Change code below to process the `response` object:\r\n    console.log(JSON.stringify(response, null, 2));\r\n\r\nasync function authorize() {\r\n\t// TODO: Change placeholder below to generate authentication credentials. See\r\n\t// https://developers.google.com/sheets/quickstart/nodejs#step_3_set_up_the_sample\r\n\t//\r\n\t// Authorize using one of the following scopes:\r\n\t//   'https://www.googleapis.com/auth/drive'\r\n\t//   'https://www.googleapis.com/auth/drive.file'\r\n\t//   'https://www.googleapis.com/auth/spreadsheets'\r\n\tlet authClient = null;\r\n  \r\n\tif (authClient == null) {\r\n\t  throw Error('authentication failed');\r\n\t}\r\n  \r\n\treturn authClient;\r\n  }\r\n\r\nconst fs = require('fs').promises;\r\nconst path = require('path');\r\nconst process = require('process');\r\nconst {authenticate} = require('@google-cloud/local-auth');\r\nconst {google} = require('googleapis');\r\n\r\n// If modifying these scopes, delete token.json.\r\nconst SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly'];\r\n// The file token.json stores the user's access and refresh tokens, and is\r\n// created automatically when the authorization flow completes for the first\r\n// time.\r\nconst TOKEN_PATH = path.join(process.cwd(), 'token.json');\r\nconst CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');\r\n\r\n/**\r\n * Reads previously authorized credentials from the save file.\r\n *\r\n * @return {Promise<OAuth2Client|null>}\r\n */\r\nasync function loadSavedCredentialsIfExist() {\r\n  try {\r\n    const content = await fs.readFile(TOKEN_PATH);\r\n    const credentials = JSON.parse(content);\r\n    return google.auth.fromJSON(credentials);\r\n  } catch (err) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Serializes credentials to a file comptible with GoogleAUth.fromJSON.\r\n *\r\n * @param {OAuth2Client} client\r\n * @return {Promise<void>}\r\n */\r\nasync function saveCredentials(client) {\r\n  const content = await fs.readFile(CREDENTIALS_PATH);\r\n  const keys = JSON.parse(content);\r\n  const key = keys.installed || keys.web;\r\n  const payload = JSON.stringify({\r\n    type: 'authorized_user',\r\n    client_id: key.client_id,\r\n    client_secret: key.client_secret,\r\n    refresh_token: client.credentials.refresh_token,\r\n  });\r\n  await fs.writeFile(TOKEN_PATH, payload);\r\n}\r\n\r\n/**\r\n * Load or request or authorization to call APIs.\r\n *\r\n */\r\n"
        }
    ]
}